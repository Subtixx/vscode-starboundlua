import * as vscode from 'vscode';

class LuaMethod
{
	name: string;
	desc: string;

	args: string[];
	argDescs: { [key: string]: string };

	returnType:string;

	constructor(name: string, desc: string = "", args:string[] = [], argDescs:{ [key: string]: string } = {}, returnType:string = "")
	{
		this.name = name;
		this.desc = desc;
		
		this.args = args;
		this.argDescs = argDescs;

		this.returnType = returnType;
	}
    
    toMarkdown() : vscode.MarkdownString
    {
        let result = new vscode.MarkdownString();
        result.appendCodeblock(this.name + " ( " + this.args.join(", ") + " )", "starboundlua");
        result.appendMarkdown(this.desc + "\n\n");
        for (const key in this.argDescs) {
            if (this.argDescs.hasOwnProperty(key)) {
                const element = this.argDescs[key];
                result.appendMarkdown("- **" + key + "**: " + element + "\n");
            }
        }
        return result;
    }
}

class LuaClass
{
	name: string;
	desc: string;
	methods: LuaMethod[];

	constructor(name: string, desc: string = "")
	{
		this.name = name;
		this.desc = desc;
		this.methods = new Array<LuaMethod>();
	}
    
    toMarkdown() : vscode.MarkdownString
    {
        let result = new vscode.MarkdownString();
        result.appendCodeblock(this.name, "starboundlua");
        result.appendMarkdown(this.desc + "\n\n");
        return result;
    }
}

class LuaConst
{
	name: string;
	desc: string;

	constructor(name: string, desc: string = "")
	{
		this.name = name;
		this.desc = desc;
	}
    
    toMarkdown() : vscode.MarkdownString
    {
        let result = new vscode.MarkdownString();
        result.appendCodeblock(this.name, "starboundlua");
        result.appendMarkdown(this.desc + "\n\n");
        return result;
    }
}

export var luaFunctions = new Array<LuaMethod>();
export var luaClasses = new Array<LuaClass>();
export var luaConsts = new Array<LuaConst>();

/*var tmpClass = new LuaClass();
tmpClass.name = "coroutine";
tmpClass.methods.push(new LuaMethod("create"));
tmpClass.methods.push(new LuaMethod("resume"));
tmpClass.methods.push(new LuaMethod("running"));
tmpClass.methods.push(new LuaMethod("status"));
tmpClass.methods.push(new LuaMethod("wrap"));
tmpClass.methods.push(new LuaMethod("yield"));*/

var tmpClass = new LuaClass("activeItem", "The activeItem table contains bindings which provide functionality for the ActiveItem and for the item's 'owner' (a ToolUser entity currently holding the item).");
tmpClass.methods.push(new LuaMethod("ownerEntityId", "Returns the entity id of the owner entity.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("ownerTeam", "Returns the damage team of the owner entity.", [], {}, "DamageTeam"));
tmpClass.methods.push(new LuaMethod("ownerAimPosition", "Returns the world aim position of the owner entity.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("ownerPowerMultiplier", "Returns the power multiplier of the owner entity.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("fireMode", "Returns the current fire mode of the item, which can be \"none\", \"primary\" or \"alt\". Single-handed items held in the off hand will receive right click as \"primary\" rather than \"alt\".", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("hand", "Returns the name of the hand that the item is currently held in, which can be \"primary\" or \"alt\".", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("handPosition", "Takes an input position (defaults to [0, 0]) relative to the item and returns a position relative to the owner entity.", ["Vec2F offset"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("aimAngleAndDirection", "Returns a table containing the float aim angle and int facing direction that would be used for the item to aim at the specified target position with the specified vertical offset. This takes into account the position of the shoulder, distance of the hand from the body, and a lot of other complex factors and should be used to control aimable weapons or tools based on the owner's aim position.", ["float aimVerticalOffset", "Vec2F targetPosition"], {}, "LuaTable"));
tmpClass.methods.push(new LuaMethod("aimAngle", "Similar to activeItem.aimAngleAndDirection but only returns the aim angle that would be calculated with the entity's current facing direction. Necessary if, for example, an item needs to aim behind the owner.", ["float aimVerticalOffset", "Vec2F targetPosition"], {}, "float"));
tmpClass.methods.push(new LuaMethod("setHoldingItem", "Sets whether the owner is visually holding the item.", ["bool holdingItem"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setBackArmFrame", "Sets the arm image frame that the item should use when held behind the player, or clears it to the default rotation arm frame if no frame is specified.", ["String armFrame"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setFrontArmFrame", "Sets the arm image frame that the item should use when held in front of the player, or clears it to the default rotation arm frame if no frame is specified.", ["String armFrame"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setTwoHandedGrip", "Sets whether the item should be visually held with both hands. Does not alter the functional handedness requirement of the item.", ["bool twoHandedGrip"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setRecoil", "Sets whether the item is in a recoil state, which will translate both the item and the arm holding it slightly toward the back of the character.", ["bool recoil"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setOutsideOfHand", "Sets whether the item should be visually rendered outside the owner's hand. Items outside of the hand will be rendered in front of the arm when held in front and behind the arm when held behind.", ["bool outsideOfHand"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setArmAngle", "Sets the angle to which the owner's arm holding the item should be rotated.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setFacingDirection", "Sets the item's requested facing direction, which controls the owner's facing. Positive direction values will face right while negative values will face left. If the owner holds two items which request opposing facing directions, the direction requested by the item in the primary hand will take precedence.", ["float direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageSources", "Sets a list of active damage sources with coordinates relative to the owner's position or clears them if unspecified.", ["List<DamageSource> damageSources"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setItemDamageSources", "Sets a list of active damage sources with coordinates relative to the item's hand position or clears them if unspecified.", ["List<DamageSource> damageSources"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setShieldPolys", "Sets a list of active shield polygons with coordinates relative to the owner's position or clears them if unspecified.", ["List<PolyF> shieldPolys"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setItemShieldPolys", "Sets a list of active shield polygons with coordinates relative to the item's hand position or clears them if unspecified.", ["List<PolyF> shieldPolys"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setForceRegions", "Sets a list of active physics force regions with coordinates relative to the owner's position or clears them if unspecified.", ["List<PhysicsForceRegion> forceRegions"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setItemForceRegions", "Sets a list of active physics force regions with coordinates relative to the item's hand position or clears them if unspecified.", ["List<PhysicsForceRegion> forceRegions"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCursor", "Sets the item's overriding cursor image or clears it if unspecified.", ["String cursor"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setScriptedAnimationParameter", "Sets a parameter to be used by the item's scripted animator.", ["String parameter", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setInventoryIcon", "Sets the inventory icon of the item.", ["String image"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setInstanceValue", "Sets an instance value (parameter) of the item.", ["String parameter", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("callOtherHandScript", "Attempts to call the specified function name with the specified argument values in the context of an ActiveItem held in the opposing hand and synchronously returns the result if successful.", ["String functionName", "[LuaValue args ...]"], {}, "LuaValue"));
tmpClass.methods.push(new LuaMethod("interact", "Triggers an interact action on the owner as if they had initiated an interaction and the result had returned the specified interaction type and configuration. Can be used to e.g. open GUI windows normally triggered by player interaction with entities.", ["String interactionType", "Json config", "[EntityId sourceEntityId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("emote", "Triggers the owner to perform the specified emote.", ["String emote"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCameraFocusEntity", "If the owner is a player, sets that player's camera to be centered on the position of the specified entity, or recenters the camera on the player's position if no entity id is specified.", ["[EntityId entity]"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("activeItemAnimation", "The activeItemAnimation table contains bindings available to client-side animation scripts for active items.");
tmpClass.methods.push(new LuaMethod("ownerPosition", "Returns the current entity position of the item's owner.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("ownerAimPosition", "Returns the current world aim position of the item's owner.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("ownerArmAngle", "Returns the current angle of the arm holding the item.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("ownerFacingDirection", "Returns the current facing direction of the item's owner. Will return 1 for right or -1 for left.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("handPosition", "Takes an input position (defaults to [0, 0]) relative to the item and returns a position relative to the owner entity.", ["[Vec2F offset]"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("partPoint", "Returns a transformation of the specified Vec2F parameter configured on the specified animation part, relative to the owner's position.", ["String partName", "String propertyName"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("partPoly", "Returns a transformation of the specified PolyF parameter configured on the specified animation part, relative to the owner's position.", ["String partName", "String propertyName"], {}, "PolyF"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("mcontroller", "The `mcontroller` table sometimes contains functions relating to the actor movement controller.\nThe `mcontroller` table contains functions relating to the movement controller.");
tmpClass.methods.push(new LuaMethod("boundBox", "Returns a rect containing the entire collision of the movement controller, in local coordinates.", [], {}, "RectF"));
tmpClass.methods.push(new LuaMethod("collisionPoly", "Returns the collision poly of the movement controller, in local coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("collisionBody", "Returns the collision poly of the movement controller, in world coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("mass", "Returns the configured mass of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("position", "Returns the current position of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xPosition", "Returns the current horizontal position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yPosition", "Returns the current vertical position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("velocity", "Returns the current velocity of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xVelocity", "Returns the current horizontal speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yVelocity", "Returns the current vertical speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("rotation", "Returns the current rotation of the movement controller in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("isColliding", "Returns whether the movement controller is currently colliding with world geometry or a PhysicsMovingCollision.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isNullColliding", "Returns whether the movement controller is currently colliding with null world geometry. Null collision occurs in unloaded sectors.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isCollisionStuck", "Returns whether the movement controller is currently stuck colliding. Movement controllers can stick if the stickyCollision movement parameter is set.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("stickingDirection", "Returns the angle that the movement controller is currently stuck at, in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidPercentage", "Returns the percentage of the collision poly currently submerged in liquid;", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidId", "Returns the liquid ID of the liquid that the movement controller is currently submerged in. If this is several liquids this returns the most plentiful one.", [], {}, "LiquidId"));
tmpClass.methods.push(new LuaMethod("onGround", "Returns whether the movement controller is currently on ground.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("zeroG", "Returns true if the movement controller is at a world position without gravity or if gravity has been disabled.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("atWorldLimit", "Returns true if the movement controller is touching the bottom or the top (unless bottomOnly is specified) of the world.", ["[bool bottomOnly]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setAnchorState", "Anchors the movement controller to an anchorable entity at the given anchor index.", ["EntityId anchorableEntity", "size_t anchorPosition"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetAnchorState", "Reset the anchor state.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("anchorState", "Returns ID of anchored entity and index of the anchor position.", [], {}, "EntityId,int"));
tmpClass.methods.push(new LuaMethod("setPosition", "Sets the position of the movement controller.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXPosition", "Sets the horizontal position of the movement controller.", ["float x"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYPosition", "Sets the vertical position of the movement controller.", ["float y"], {}, "void"));
tmpClass.methods.push(new LuaMethod("translate", "Moves the movement controller by the vector provided.", ["Vec2F direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setVelocity", "Sets the velocity of the movement controller.", ["Vec2F velocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXVelocity", "Sets the horizontal velocity of the movement controller.", ["Vec2F xVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYVelocity", "Sets the vertical velocity of the movement controller.", ["Vec2F yVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addMomentum", "Adds (momentum / mass) velocity to the movement controller.", ["Vec2F momentum"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setRotation", "Sets the rotation of the movement controller. Angle is in radians.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("baseParameters", "Returns the base movement parameters.", [], {}, "ActorMovementParameters"));
tmpClass.methods.push(new LuaMethod("walking", "Returns whether the actor movement controller is currently walking.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("running", "Returns whether the actor movement controller is currently running.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("movingDirection", "Returns the direction that the actor movement controller is currently moving in. -1 for left, 1 for right.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("facingDirection", "Returns the facing direction. -1 for left, 1 for right.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("crouching", "Returns whether the controller is currently crouching.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("flying", "Returns whether the controller is currently flying.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("falling", "Returns whether the controller is currently falling.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("canJump", "Returns whether the controller can currently jump.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("jumping", "Returns whether the controller is currently jumping.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("groundMovement", "Returns whether the controller is currently in a ground movement state. Movement controllers can be in ground movement even when onGround returns false.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("liquidMovement", "Returns whether the controller is currently in liquid movement mode.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("controlRotation", "Rotates the controller. Each control adds to the previous one.", ["float rotation"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlAcceleration", "Controls acceleration. Each control adds to the previous one.", ["Vec2F acceleration"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlForce", "Controls force. Each control adds to the previous one.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachVelocity", "Approaches the targetVelocity using the force provided. If the current velocity is higher than the provided targetVelocity, the targetVelocity will still be approached, effectively slowing down the entity. Each control overrides the previous one.", ["Vec2F targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachVelocityAlongAngle", "Approaches the targetVelocity but only along the provided angle, not affecting velocity in the perpendicular axis. If positiveOnly, then it will not slow down the movementController if it is already moving faster than targetVelocity. Each control overrides the previous one.", ["float angle", "float targetVelocity", "float maxControlForce", "bool positiveOnly = false"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachXVelocity", "Approaches an X velocity. Same as using approachVelocityAlongAngle with angle 0. Each control overrides the previous one.", ["float targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachYVelocity", "Approaches a Y velocity. Same as using approachVelocityAlongAngle with angle (Pi / 2). Each control overrides the previous one.", ["float targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlParameters", "Changes movement parameters. Parameters are merged into the base parameters. Each control is merged into the previous one.", ["ActorMovementParameters parameters"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlModifiers", "Changes movement modifiers. Modifiers are merged into the base modifiers. Each control is merged into the previous one.", ["ActorMovementModifiers modifiers"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlMove", "Controls movement in a direction. Each control replaces the previous one.", ["float direction", "bool run"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlFace", "Controls the facing direction. Each control replaces the previous one.", ["float direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlDown", "Controls dropping through platforms.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlCrouch", "Controls crouching.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlJump", "Controls starting a jump. Only has an effect if canJump is true.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlHoldJump", "Keeps holding jump. Will not trigger a new jump, and can be held in the air.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlFly", "Controls flying in the specified direction (or {0, 0} to stop) with the configured flightSpeed parameter. Each control overrides the previous one.", ["Vec2F direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("autoClearControls", "Returns whether the controller is currently set to auto clear controls before each script update.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setAutoClearControls", "Set whether to automatically clear controls before each script update.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearControls", "Manually clear all controls.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("boundBox", "Returns a rect containing the entire collision of the movement controller, in local coordinates.", [], {}, "RectF"));
tmpClass.methods.push(new LuaMethod("collisionPoly", "Returns the collision poly of the movement controller, in local coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("collisionBody", "Returns the collision poly of the movement controller, in world coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("mass", "Returns the configured mass of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("position", "Returns the current position of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xPosition", "Returns the current horizontal position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yPosition", "Returns the current vertical position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("velocity", "Returns the current velocity of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xVelocity", "Returns the current horizontal speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yVelocity", "Returns the current vertical speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("rotation", "Returns the current rotation of the movement controller in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("isColliding", "Returns whether the movement controller is currently colliding with world geometry or a PhysicsMovingCollision.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isNullColliding", "Returns whether the movement controller is currently colliding with null world geometry. Null collision occurs in unloaded sectors.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isCollisionStuck", "Returns whether the movement controller is currently stuck colliding. Movement controllers can stick if the stickyCollision movement parameter is set.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("stickingDirection", "Returns the angle that the movement controller is currently stuck at, in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidPercentage", "Returns the percentage of the collision poly currently submerged in liquid;", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidId", "Returns the liquid ID of the liquid that the movement controller is currently submerged in. If this is several liquids this returns the most plentiful one.", [], {}, "LiquidId"));
tmpClass.methods.push(new LuaMethod("onGround", "Returns whether the movement controller is currently on ground.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("zeroG", "Returns true if the movement controller is at a world position without gravity or if gravity has been disabled.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("atWorldLimit", "Returns true if the movement controller is touching the bottom or the top (unless bottomOnly is specified) of the world.", ["[bool bottomOnly]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setAnchorState", "Anchors the movement controller to an anchorable entity at the given anchor index.", ["EntityId anchorableEntity", "size_t anchorPosition"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetAnchorState", "Reset the anchor state.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("anchorState", "Returns ID of anchored entity and index of the anchor position.", [], {}, "EntityId,int"));
tmpClass.methods.push(new LuaMethod("setPosition", "Sets the position of the movement controller.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXPosition", "Sets the horizontal position of the movement controller.", ["float x"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYPosition", "Sets the vertical position of the movement controller.", ["float y"], {}, "void"));
tmpClass.methods.push(new LuaMethod("translate", "Moves the movement controller by the vector provided.", ["Vec2F direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setVelocity", "Sets the velocity of the movement controller.", ["Vec2F velocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXVelocity", "Sets the horizontal velocity of the movement controller.", ["Vec2F xVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYVelocity", "Sets the vertical velocity of the movement controller.", ["Vec2F yVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addMomentum", "Adds (momentum / mass) velocity to the movement controller.", ["Vec2F momentum"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setRotation", "Sets the rotation of the movement controller. Angle is in radians.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("baseParameters", "Returns the base movement parameters.", [], {}, "ActorMovementParameters"));
tmpClass.methods.push(new LuaMethod("walking", "Returns whether the actor movement controller is currently walking.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("running", "Returns whether the actor movement controller is currently running.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("movingDirection", "Returns the direction that the actor movement controller is currently moving in. -1 for left, 1 for right.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("facingDirection", "Returns the facing direction. -1 for left, 1 for right.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("crouching", "Returns whether the controller is currently crouching.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("flying", "Returns whether the controller is currently flying.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("falling", "Returns whether the controller is currently falling.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("canJump", "Returns whether the controller can currently jump.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("jumping", "Returns whether the controller is currently jumping.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("groundMovement", "Returns whether the controller is currently in a ground movement state. Movement controllers can be in ground movement even when onGround returns false.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("liquidMovement", "Returns whether the controller is currently in liquid movement mode.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("controlRotation", "Rotates the controller. Each control adds to the previous one.", ["float rotation"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlAcceleration", "Controls acceleration. Each control adds to the previous one.", ["Vec2F acceleration"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlForce", "Controls force. Each control adds to the previous one.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachVelocity", "Approaches the targetVelocity using the force provided. If the current velocity is higher than the provided targetVelocity, the targetVelocity will still be approached, effectively slowing down the entity. Each control overrides the previous one.", ["Vec2F targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachVelocityAlongAngle", "Approaches the targetVelocity but only along the provided angle, not affecting velocity in the perpendicular axis. If positiveOnly, then it will not slow down the movementController if it is already moving faster than targetVelocity. Each control overrides the previous one.", ["float angle", "float targetVelocity", "float maxControlForce", "bool positiveOnly = false"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachXVelocity", "Approaches an X velocity. Same as using approachVelocityAlongAngle with angle 0. Each control overrides the previous one.", ["float targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlApproachYVelocity", "Approaches a Y velocity. Same as using approachVelocityAlongAngle with angle (Pi / 2). Each control overrides the previous one.", ["float targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlParameters", "Changes movement parameters. Parameters are merged into the base parameters. Each control is merged into the previous one.", ["ActorMovementParameters parameters"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlModifiers", "Changes movement modifiers. Modifiers are merged into the base modifiers. Each control is merged into the previous one.", ["ActorMovementModifiers modifiers"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlMove", "Controls movement in a direction. Each control replaces the previous one.", ["float direction", "bool run"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlFace", "Controls the facing direction. Each control replaces the previous one.", ["float direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlDown", "Controls dropping through platforms.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlCrouch", "Controls crouching.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlJump", "Controls starting a jump. Only has an effect if canJump is true.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlHoldJump", "Keeps holding jump. Will not trigger a new jump, and can be held in the air.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("controlFly", "Controls flying in the specified direction (or {0, 0} to stop) with the configured flightSpeed parameter. Each control overrides the previous one.", ["Vec2F direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("autoClearControls", "Returns whether the controller is currently set to auto clear controls before each script update.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setAutoClearControls", "Set whether to automatically clear controls before each script update.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearControls", "Manually clear all controls.", [], {}, "void"));

tmpClass.methods.push(new LuaMethod("parameters", "Returns a table containing the movement parameters for the movement controller.", [], {}, "MovementParameters"));
tmpClass.methods.push(new LuaMethod("applyParameters", "Applies the given parameters to the movement controller. The provided parameters are merged into the current movement parameters.", ["Json parameters"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetParameters", "Resets movement parameters to their original state.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("mass", "Returns the configured mass of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("position", "Returns the current position of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xPosition", "Returns the current horizontal position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yPosition", "Returns the current vertical position of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("velocity", "Returns the current velocity of the movement controller.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xVelocity", "Returns the current horizontal speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("yVelocity", "Returns the current vertical speed of the movement controller.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("rotation", "Returns the current rotation of the movement controller in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("collisionPoly", "Returns the collision poly of the movement controller, in local coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("collisionBody", "Returns the collision poly of the movement controller, in world coordinates.", [], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("collisionBoundBox", "Returns a rect containing the entire collision poly of the movement controller, in world coordinates.", [], {}, "RectF"));
tmpClass.methods.push(new LuaMethod("localBoundBox", "Returns a rect containing the entire collision of the movement controller, in local coordinates.", [], {}, "RectF"));
tmpClass.methods.push(new LuaMethod("isColliding", "Returns whether the movement controller is currently colliding with world geometry or a PhysicsMovingCollision.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isNullColliding", "Returns whether the movement controller is currently colliding with null world geometry. Null collision occurs in unloaded sectors.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isCollisionStuck", "Returns whether the movement controller is currently stuck colliding. Movement controllers can stick if the stickyCollision movement parameter is set.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("stickingDirection", "Returns the angle that the movement controller is currently stuck at, in radians.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidPercentage", "Returns the percentage of the collision poly currently submerged in liquid;", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("liquidId", "Returns the liquid ID of the liquid that the movement controller is currently submerged in. If this is several liquids this returns the most plentiful one.", [], {}, "LiquidId"));
tmpClass.methods.push(new LuaMethod("onGround", "Returns whether the movement controller is currently on ground.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("zeroG", "Returns true if the movement controller is at a world position without gravity or if gravity has been disabled.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("atWorldLimit", "Returns true if the movement controller is touching the bottom or the top (unless bottomOnly is specified) of the world.", ["[bool bottomOnly]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setPosition", "Sets the position of the movement controller.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXPosition", "Sets the horizontal position of the movement controller.", ["float x"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYPosition", "Sets the vertical position of the movement controller.", ["float y"], {}, "void"));
tmpClass.methods.push(new LuaMethod("translate", "Moves the movement controller by the vector provided.", ["Vec2F direction"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setVelocity", "Sets the velocity of the movement controller.", ["Vec2F velocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setXVelocity", "Sets the horizontal velocity of the movement controller.", ["Vec2F xVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setYVelocity", "Sets the vertical velocity of the movement controller.", ["Vec2F yVelocity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addMomentum", "Adds (momentum / mass) velocity to the movement controller.", ["Vec2F momentum"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setRotation", "Sets the rotation of the movement controller. Angle is in radians.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("rotate", "Rotates the movement controller by an angle relative to its current angle. Angle is in radians.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("accelerate", "Accelerates the movement controller by the given acceleration for one tick.", ["Vec2F acceleration"], {}, "void"));
tmpClass.methods.push(new LuaMethod("force", "Accelerates the movement controller by (force / mass) for one tick.", ["Vec2F force"], {}, "void"));
tmpClass.methods.push(new LuaMethod("approachVelocity", "Approaches the targetVelocity using the force provided. If the current velocity is higher than the provided targetVelocity, the targetVelocity will still be approached, effectively slowing down the entity.", ["Vec2F targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("approachVelocityAlongAngle", "Approaches the targetVelocity but only along the provided angle, not affecting velocity in the perpendicular axis. If positiveOnly, then it will not slow down the movementController if it is already moving faster than targetVelocity.", ["float angle", "float targetVelocity", "float maxControlForce", "bool positiveOnly = false"], {}, "void"));
tmpClass.methods.push(new LuaMethod("approachXVelocity", "Approaches an X velocity. Same as using approachVelocityAlongAngle with angle 0.", ["float targetVelocity", "float maxControlForce"], {}, "void"));
tmpClass.methods.push(new LuaMethod("approachYVelocity", "Approaches a Y velocity. Same as using approachVelocityAlongAngle with angle (Pi / 2).", ["float targetVelocity", "float maxControlForce"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("animator", "The *animator* table contains functions that relate to an attached networked animator. Networked animators are found in:");
tmpClass.methods.push(new LuaMethod("setAnimationState", "Sets an animation state. If startNew is true, restart the animation loop if it's already active. Returns whether the state was set.", ["String stateType", "String State", "bool startNew = false"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("animationState", "Returns the current state for a state type.", ["String stateType"], {}, "String"));
tmpClass.methods.push(new LuaMethod("animationStateProperty", "Returns the value of the specified property for a state type.", ["String stateType", "String propertyName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("setGlobalTag", "Sets a global animator tag. A global tag replaces any tag <tagName> with the specified tagValue across all animation parts.", ["String tagName", "String tagValue"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPartTag", "Sets a local animator tag. A part tag replaces any tag <tagName> with the specified tagValue in the partType animation part only.", ["String partType", "String tagName", "String tagValue"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setFlipped", "Sets whether the animator should be flipped horizontally.", ["bool flipped"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAnimationRate", "Sets the animation rate of the animator.", ["float rate"], {}, "void"));
tmpClass.methods.push(new LuaMethod("rotateGroup", "Rotates a rotation group to the specified angle. If immediate, ignore rotation speed.\n*NOTE:* Rotation groups have largely been replaced by transformation groups and should only be used in a context where maintaining a rotation speed is important. When possible use transformation groups.", ["String rotationGroup", "float targetAngle", "bool immediate"], {}, "void"));
tmpClass.methods.push(new LuaMethod("currentRotationAngle", "Returns the current angle for a rotation group.", ["String rotationGroup"], {}, "float"));
tmpClass.methods.push(new LuaMethod("hasTransformationGroup", "Returns whether the animator contains the specified transformation group.", ["String transformationGroup"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("translateTransformationGroup", "Translates the specified transformation group.", ["String transformationGroup", "Vec2F translate"], {}, "void"));
tmpClass.methods.push(new LuaMethod("rotateTransformationGroup", "Rotates the specified transformation group by the specified angle in radians, optionally around the specified center point.", ["String transformationGroup", "float rotation", "[Vec2F rotationCenter]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("scaleTransformationGroup", "Scales the specified transformation group by the specified scale. Optionally scale it from a scaleCenter.", ["String transformationGroup", "float/Vec2F scale", "[Vec2F scaleCenter]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("transformTransformationGroup", "Applies a custom Mat3 transform to the specified transformationGroup. The applied matrix will be:\n[a, b, tx,\n c, d, ty,\n 0, 0, 1]", ["String transformationGroup", "float a", "float b", "float c", "float d", "float tx", "float ty"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetTransformationGroup", "Resets a transformationGroup to the identity transform.\n[1, 0, 0\n0, 1, 0,\n0, 1, 1]", ["String transformationGroup"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParticleEmitterActive", "Sets a particle emitter to be active or inactive.", ["String emitterName", "bool active"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParticleEmitterEmissionRate", "Sets the rate at which a particle emitter emits particles while active.", ["String emitterName", "float emissionRate"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParticleEmitterBurstCount", "Sets the amount of each particle the emitter will emit when using burstParticleEmitter.", ["String emitterName", "unsigned burstCount"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParticleEmitterOffsetRegion", "Sets an offset region for the particle emitter. Any particles spawned will have a randomized offset within the region added to their position.", ["String emitterName", "RectF offsetRegion"], {}, "void"));
tmpClass.methods.push(new LuaMethod("burstParticleEmitter", "Spawns the entire set of particles burstCount times, where burstCount can be configured in the animator or set by setParticleEmitterBurstCount.", ["String emitterName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLightActive", "Sets a light to be active/inactive.", ["String lightName, bool active"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLightPosition", "Sets the position of a light.", ["String lightName, Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLightColor", "Sets the color of a light. Brighter color gives a higher light intensity.", ["String lightName, Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLightPointAngle", "Sets the angle of a pointLight.", ["String lightName, float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("hasSound", "Returns whether the animator has a sound by the name of soundName", ["String soundName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setSoundPool", "Sets the list of sound assets to pick from when playing a sound.", ["String soundName", "List<String> soundPool"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setSoundPosition", "Sets the position that a sound is played at.", ["String soundName", "Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("playSound", "Plays a sound. Optionally loop loops times. 0 plays the sound once (no loops), -1 loops indefinitely.", ["String soundName", "[int loops = 0]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setSoundVolume", "Sets the volume of a sound. Optionally smoothly transition the volume over rampTime seconds.", ["String soundName", "float volume", "[float rampTime = 0.0]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setSoundPitch", "Sets the relative pitch of a sound. Optionally smoothly transition the pitch over rampTime seconds.", ["String soundName", "float pitch", "[float rampTime = 0.0]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("stopAllSounds", "Stops all instances of the specified sound.", ["String soundName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setEffectActive", "Sets a configured effect to be active/inactive.", ["String effect", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("partPoint", "Returns a Vec2F configured in a part's properties with all of the part's transformations applied to it.", ["String partName", "String propertyName"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("partPoly", "Returns a PolyF configured in a part's properties with all the part's transformations applied to it.", ["String partName", "String propertyName"], {}, "PolyF"));
tmpClass.methods.push(new LuaMethod("partProperty", "Returns an animation part property without applying any transformations.", ["String partName", "String propertyName"], {}, "Json"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("celestial", "The *celestial* table contains functions that relate to the client sky, flying the player ship, system positions for planets, system objects, and the celestial database.");
tmpClass.methods.push(new LuaMethod("skyFlying", "Returns whether the client sky is currently flying.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("skyFlyingType", "Returns the type of flying the client sky is currently performing.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("skyWarpPhase", "Returns the current warp phase of the client sky, if warping.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("skyWarpProgress", "Returns a value between 0 and 1 for how far through warping the sky is currently.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("skyInHyperspace", "Returns whether the sky is currently under hyperspace flight.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("skyFlying", "Flies the player ship to the specified SystemLocation in the specified system.\nSystemLocation is either of the following types: Null, CelestialCoordinate, Object, Vec2F\nThe locations are specified as a pair of type and value", ["Vec3I system", "SystemLocation destination"], {}, "flyShip"));
tmpClass.methods.push(new LuaMethod("flying", "Returns whether the player ship is flying", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("shipSystemPosition", "Returns the current position of the ship in the system.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("shipDestination", "Returns the current destination of the player ship.", [], {}, "SystemLocation"));
tmpClass.methods.push(new LuaMethod("shipLocation", "Returns the current system location of the player ship.", [], {}, "SystemLocation"));
tmpClass.methods.push(new LuaMethod("currentSystem", "Returns the CelestialCoordinate for system the ship is currently in.", [], {}, "CelestialCoordinate"));
tmpClass.methods.push(new LuaMethod("planetSize", "Returns the diameter of the specified planet in system space.", ["CelestialCoordinate planet"], {}, "float"));
tmpClass.methods.push(new LuaMethod("planetPosition", "Returns the position of the specified planet in system space.", ["CelestialCoordinate planet"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("planetParameters", "Returns the celestial parameters for the specified planet.", ["CelestialCoordinate planet"], {}, "CelestialParameters"));
tmpClass.methods.push(new LuaMethod("visitableParameters", "Returns the visitable parameters for the specified visitable planet. For unvisitable planets, returns nil.", ["CelestialCoordinate planet"], {}, "VisitableParameters"));
tmpClass.methods.push(new LuaMethod("planetName", "Returns the name of the specified planet.", ["CelestialCoordinate planet"], {}, "String"));
tmpClass.methods.push(new LuaMethod("planetSeed", "Returns the seed for the specified planet.", ["CelestialCoordinate planet"], {}, "uint64_t"));
tmpClass.methods.push(new LuaMethod("clusterSize", "Returns the diameter of the specified planet and its orbiting moons.", ["CelestialCoordinate planet"], {}, "float"));
tmpClass.methods.push(new LuaMethod("planetOres", "Returns a list of ores available on the specified planet.", ["CelestialCoordinate planet"], {}, "List<String>"));
tmpClass.methods.push(new LuaMethod("systemPosition", "Returns the position of the specified location in the *current system*.", ["SystemLocation location"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("orbitPosition", "Returns the calculated position of the provided orbit.", ["Orbit orbit"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("systemObjects", "Returns a list of the Uuids for objects in the current system.", [], {}, "List<Uuid>"));
tmpClass.methods.push(new LuaMethod("objectType", "Returns the type of the specified object.", ["Uuid uuid"], {}, "String"));
tmpClass.methods.push(new LuaMethod("objectParameters", "Returns the parameters for the specified object.", ["Uuid uuid"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("systemSpawnObject", "Spawns an object of typeName at position. Optionally with the specified UUID and parameters.\nObjects are limited to be spawned outside a distance of  /systemworld.config:clientSpawnObjectPadding from any planet surface (including moons), star surface, planetary orbit (including moons), or permanent objects orbits, and at most within clientSpawnObjectPadding from the outermost orbit.", ["String typeName", "Vec2F position", "[Uuid uuid]", "[Json parameters]"], {}, "Uuid"));
tmpClass.methods.push(new LuaMethod("playerShips", "Returns a list of the player ships in the current system.", [], {}, "List<Uuid>"));
tmpClass.methods.push(new LuaMethod("playerShipPosition", "Returns the position of the specified player ship.", ["Uuid uuid"], {}, "playerShipPosition"));
tmpClass.methods.push(new LuaMethod("objectParameters", "Returns the children for the specified celestial coordinate. For systems, return planets, for planets, return moons.", ["CelestialCoordinate coordinate"], {}, "List<CelestialCoordinate>"));
tmpClass.methods.push(new LuaMethod("scanSystems", "Returns a list of systems in the given region. This scans for systems asynchronously, meaning it may not return all systems if they have not been generated or sent to the client. Use scanRegionFullyLoaded to see if this is the case.", ["RectI region"], {}, "List<CelestialCoordinate>"));
tmpClass.methods.push(new LuaMethod("scanConstellationLines", "Returns the constellation lines for the specified universe region.", ["RectI region"], {}, "List<pair<Vec2I,Vec2I>>"));
tmpClass.methods.push(new LuaMethod("scanRegionFullyLoaded", "Returns whether the specified universe region has been fully loaded.", ["RectI region"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("centralBodyImages", "Returns the images with scales for the central body (star) for the specified system coordinate.", ["CelestialCoordinate system"], {}, "List<pair<String,float>>"));
tmpClass.methods.push(new LuaMethod("planetaryObjectImages", "Returns the smallImages with scales for the specified planet or moon.", ["CelestialCoordinate coordinate"], {}, "List<pair<String,float>>"));
tmpClass.methods.push(new LuaMethod("worldImages", "Returns the generated world images with scales for the specified planet or moon.", ["CelestialCoordinate coordinate"], {}, "List<pair<String,float>>"));
tmpClass.methods.push(new LuaMethod("starImages", "Returns the star image for the specified system. Requires a twinkle time to provide the correct image frame.", ["CelestialCoordinate system", "float twinkleTime"], {}, "List<pair<String,float>>"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("CommandProcessor", "The command processor has a single binding for performing admin checks, available on the *CommandProcessor* table.");
tmpClass.methods.push(new LuaMethod("adminCheck", "Checks whether the specified connection id is authorized to perform admin actions and returns nil if authorization is succesful. If unauthorized, returns a String error message to display to the client requesting the action, which may include the specified action description, such as \"Insufficient privileges to do the time warp again.\"", ["ConnectionId connectionId", "String actionDescription"], {}, "String"));

tmpClass = new LuaClass("config", "The `config` lua bindings relate to anything that has a configuration and needs to access configuration parameters.");
tmpClass.methods.push(new LuaMethod("getParameter", "Returns the value for the specified config parameter. If there is no value set, returns the default.", ["String parameter", "Json default"], {}, "Json"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("pane", "These pane bindings are available to container interface panes and include functions not specifically related to widgets within the pane.");
tmpClass.methods.push(new LuaMethod("containerEntityId", "Returns the entity id of the container that this pane is connected to.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("playerEntityId", "Returns the entity id of the player that opened this pane.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("dismiss", "Closes the pane.", [], {}, "void"));

tmpClass.methods.push(new LuaMethod("sourceEntity", "Returns the entity id of the pane's source entity.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("dismiss", "Closes the pane.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("playSound", "Plays the specified sound asset, optionally looping the specified number of times or at the specified volume.", ["String sound", "[int loops]", "[float volume]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("stopAllSounds", "Stops all instances of the given sound asset, and returns true if any sounds were stopped and false otherwise.", ["String sound"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setTitle", "Sets the window title and subtitle.", ["String title", "String subtitle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setTitleIcon", "Sets the window icon.", ["String image"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("entity", "The *entity* table contains functions that are common among all entities. Every function refers to the entity the script context is running on.");
tmpClass.methods.push(new LuaMethod("id", "Returns the id number of the entity.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("damageTeam", "Returns a table of the entity's damage team type and team number. Ex: {type = \"enemy\", team = 0}", [], {}, "LuaTable"));
tmpClass.methods.push(new LuaMethod("isValidTarget", "Returns whether the provided entity is a valid target of the current entity. An entity is a valid target if they can be damaged, and in the case of monsters and NPCs if they are aggressive.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("distanceToEntity", "Returns the vector distance from the current entity to the provided entity.", ["EntityId entityId"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityInSight", "Returns whether the provided entity is in line of sight of the current entity.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("position", "Returns the position of the current entity.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityType", "Returns the  type of the current entity.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("uniqueId", "Returns the unique ID of the entity. Returns nil if there is no unique ID.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("persistent", "Returns true if the entity is persistent (will be saved to disk on sector unload) or false otherwise.", [], {}, "bool"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("item", "The `item` table is available in all scripted items and contains functions relating to the item itself.");
tmpClass.methods.push(new LuaMethod("name", "Returns the name of the item.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("count", "Returns the stack count of the item.", [], {}, "size_t"));
tmpClass.methods.push(new LuaMethod("setCount", "Sets the item count. Returns any overflow.", ["size_t count"], {}, "size_t"));
tmpClass.methods.push(new LuaMethod("maxStack", "Returns the max number of this item that will fit in a stack.", [], {}, "size_t"));
tmpClass.methods.push(new LuaMethod("matches", "Returns whether the item matches the specified item. If exactMatch is true then both the items' names and parameters are compared, otherwise only the items' names.", ["ItemDescriptor desc", "[bool exactMatch]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("consume", "Consumes items from the stack. Returns whether the full count was successfuly consumed.", ["size_t count"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("empty", "Returns whether the item stack is empty.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("descriptor", "Returns an item descriptor for the item.", [], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("description", "Returns the description for the item.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("friendlyName", "Returns the short description for the item.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("rarity", "Returns the rarity for the item.\n* 0 = common\n* 1 = uncommon\n* 2 = rare\n* 3 = legendary\n* 4 = essential", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("rarityString", "Returns the rarity as a string.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("price", "Returns the item price.", [], {}, "size_t"));
tmpClass.methods.push(new LuaMethod("fuelAmount", "Returns the item fuel amount.", [], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("iconDrawables", "Returns a list of the item's icon drawables.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("dropDrawables", "Returns a list of the item's itemdrop drawables.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("largeImage", "Returns the item's configured large image, if any.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("tooltipKind", "Returns the item's tooltip kind.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("category", "Returns the item's category", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("pickupSound", "Returns the item's pickup sound.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("twoHanded", "Returns whether the item is two handed.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("timeToLive", "Returns the items's time to live.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("learnBlueprintsOnPickup", "Returns a list of the blueprints learned on picking up this item.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("hasItemTag", "Returns whether the set of item tags for this item contains the specified tag.", ["String itemTag"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("pickupQuestTemplates", "Returns a list of quests acquired on picking up this item.", [], {}, "Json"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("localAnimator", "The *localAnimator* table provides bindings used by client side animation scripts (e.g. on objects and active items) to set drawables/lights and perform rendering actions.");
tmpClass.methods.push(new LuaMethod("playAudio", "Immediately plays the specified sound, optionally with the specified loop count and volume.", ["String sound", "[int loops]", "[float volume]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("spawnParticle", "Immediately spawns a particle with the specified name or configuration at the specified position.", ["Json particleConfig", "Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addDrawable", "Adds the specified drawable to the animator's list of drawables to be rendered. If a render layer is specified, this drawable will be drawn on that layer instead of the parent entity's render layer. Drawables set in this way are retained between script ticks and must be cleared manually using localAnimator.clearDrawables().\nThe drawable object must specify exactly one of the following keys to define its type:\n\n* [pair<Vec2F, Vec2F> __line__] - Defines this drawable as a line between the specified two points.\n* [List<Vec2F> __poly__] - Defines the drawable as a polygon composed of the specified points.\n* [String __image__] - Defines the drawable as an image with the specified asset path.\n\nThe following additional keys may be specified for any drawable type:\n\n* [Vec2F __position__] - Relative position of the drawable.\n* [Color __color__] - Color for the drawable. Defaults to white.\n* [bool __fullbright__] - Specifies whether the drawable is fullbright (ignores world lighting).\n\nThe following additional key may be specified for line drawables:\n\n* [float __width__] - Specifies the width of the line to be rendered.\n\nThe following transformation options may be specified for image drawables. Note that if a __transformation__ is specified, it will be used instead of other specific transformation operations.\n\n* [Mat3F __transformation__]\n* [bool __centered__]\n* [float __rotation__]\n* [bool __mirrored__]\n* [float __scale__]", ["Drawable drawable", "[String renderLayer]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearDrawables", "Clears the list of drawables to be rendered.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("addLightSource", "Adds the specified light source to the animator's list of light sources to be rendered. Light sources set in this way are retained between script ticks and must be cleared manually using localAnimator.clearLightSources(). The configuration object for the light source accepts the following keys:\n\n* Vec2F __position__\n* Color __color__\n* [bool __pointLight__]\n* [float __pointBeam__]\n* [float __beamAngle__]\n* [float __beamAmbience__]\n", ["Json lightSource"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearLightSources", "Clears the list of light sources to be rendered.", [], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("message", "The message table contains a single function, setHandler, which allows entities to receive messages sent using world.sendEntityMessage.");
tmpClass.methods.push(new LuaMethod("setHandler", "Messages of the specified message type received by this script context will call the specified function. The first two arguments passed to the handler function will be the String messageName and a bool indicating whether the message is from a local entity, followed by any arguments sent with the message.", ["String messageName", "LuaFunction handler"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("monster", "The monster table contains bindings specific to monsters which are available in addition to their common tables.");
tmpClass.methods.push(new LuaMethod("type", "Returns the monster's configured monster type.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("seed", "Returns a string representation of the monster's random seed.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("uniqueParameters", "Returns a table of the monster's unique (override) parameters.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("familyIndex", "Returns the monster's family index.", [], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("level", "Returns the monster's level.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("setDamageOnTouch", "Enables or disables the monster's touch damage.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageSources", "Sets the monster's active damage sources (or clears them if unspecified).", ["[List<DamageSource> damageSources]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageParts", "Sets the monster's active damage parts. Damage parts must be defined in the monster's configuration parameters. A damage part specifies a damage source and an animation part to anchor the damage source to. The anchor part's transformation will be applied to the damage source's damage poly, and if a vector, the damage source's knockback.", ["StringSet damageParts"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAggressive", "Sets whether the monster is currently aggressive.", ["bool aggressive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDropPool", "Sets the monster's drop pool, which determines the items that it will drop on death. This can be specified as the String name of a treasure pool, or as a Map<String, String> to specify different drop pools for different damage types. If specified as a map, the pool should contain a \"default\" entry for unhandled damage types.", ["Json dropPool"], {}, "void"));
tmpClass.methods.push(new LuaMethod("toAbsolutePosition", "Returns an absolute world position calculated from the given relative position.", ["Vec2F relativePosition"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("mouthPosition", "Returns the world position of the monster's mouth.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("flyTo", "Causes the monster to controlFly toward the given world position.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDeathParticleBurst", "Sets the name of the particle emitter (configured in the animation) to burst when the monster dies, or clears it if unspecified.", ["[String particleEmitter"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDeathSound", "Sets the name of the sound (configured in the animation) to play when the monster dies, or clears it if unspecified.", ["[String sound]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPhysicsForces", "Sets a list of physics force regions that the monster will project, used for applying forces to other nearby entities. Set an empty list to clear the force regions.", ["List<PhysicsForceRegion> forceRegions"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setName", "Sets the monster's name.", ["String name"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDisplayNametag", "Sets whether the monster should display its nametag.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("say", "Causes the monster to say the line, optionally replacing any specified tags in the text. Returns true if anything is said (i.e. the line is not empty) and false otherwise.", ["String line", "[Map<String", "String> tags]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("sayPortrait", "Similar to monster.say, but uses a portrait chat bubble with the specified portrait image.", ["String line", "String portrait", "[Map<String, String> tags]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setDamageTeam", "Sets the monster's current damage team type and number.", ["DamageTeam team"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setUniqueId", "Sets the monster's unique entity id, or clears it if unspecified.", ["[String uniqueId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageBar", "Sets the type of damage bar that the monster should display. Valid options are \"default\", \"none\" and \"special\".", ["String damageBarType"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setInteractive", "Sets whether the monster is currently interactive.", ["bool interactive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAnimationParameter", "Sets a networked scripted animator parameter to be used in a client side rendering script using animationConfig.getParameter.", ["String key", "Json value"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("npc", "The `npc` table is for functions relating directly to the current npc. It is available only in NPC scripts.");
tmpClass.methods.push(new LuaMethod("toAbsolutePosition", "Returns the specified local position in world space.", ["Vec2F offset"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("species", "Returns the species of the npc.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("gender", "Returns the gender of the npc", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("humanoidIdentity", "Returns the specific humanoid identity of the npc, containing information such as hair style and idle pose.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("npcType", "Returns the npc type of the npc.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("seed", "Returns the seed used to generate this npc.", [], {}, "uint64_t"));
tmpClass.methods.push(new LuaMethod("level", "Returns the level of the npc.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("dropPools", "Returns the list of treasure pools that will spawn when the npc dies.", [], {}, "List<String>"));
tmpClass.methods.push(new LuaMethod("setDropPools", "Sets the list of treasure pools that will spawn when the npc dies.", ["List<String> pools"], {}, "void"));
tmpClass.methods.push(new LuaMethod("energy", "Returns the current energy of the npc. Same as status.resource(\"energy\")", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("maxEnergy", "Returns the current energy of the npc. Same as status.maxResource(\"energy\")", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("say", "Makes the npc say a string. Optionally pass in tags to replace text tags. Optionally give config options for the chat message.\n\nReturns whether the chat message was successfully added.\n\nAvailable options:\n\n{\n  drawBorder = true,\n  fontSize = 8,\n  color = {255, 255, 255},\n  sound = \"/sfx/humanoid/avian_chatter_male1.ogg\"\n}\n", ["String line", "[Map<String,String> tags]", "[Json config]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("sayPortrait", "Makes the npc say a line, with a portrait chat bubble. Optionally pass in tags to replace text tags. Optionally give config options for the chat message.\nReturns whether the chat message was successfully added.\nAvailable options:\n\n{\n  drawMoreIndicator = true,\n  sound = \"/sfx/humanoid/avian_chatter_male1.ogg\"\n}\n", ["String line", "String portrait", "[Map<String,String> tags]", "[Json config]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("emote", "Makes the npc show a facial emote.", ["String emote"], {}, "void"));
tmpClass.methods.push(new LuaMethod("dance", "Sets the current dance for the npc. Dances are defined in .dance files.", ["String dance"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setInteractive", "Sets whether the npc should be interactive.", ["bool interactive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLounging", "Sets the npc to lounge in a loungeable. Optionally specify which anchor (seat) to use.\nReturns whether the npc successfully lounged.", ["EntityId loungeable", "[size_t anchorIndex]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("resetLounging", "Makes the npc stop lounging.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("isLounging", "Returns whether the npc is currently lounging.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("loungingIn", "Returns the EntityId of the loungeable the NPC is currently lounging in. Returns nil if not lounging.", [], {}, "Maybe<EntityId>"));
tmpClass.methods.push(new LuaMethod("setOfferedQuests", "Sets the list of quests the NPC will offer.", ["JsonArray quests"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setTurnInQuests", "Sets the list of quests the played can turn in at this npc.", ["JsonArray quests"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setItemSlot", "Sets the specified item slot to contain the specified item.\n\nPossible equipment items slots:\n* head\n* headCosmetic\n* chest\n* chestCosmetic\n* legs\n* legsCosmetic\n* back\n* backCosmetic\n* primary\n* alt", ["String slot", "ItemDescriptor item"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("getItemSlot", "Returns the item currently in the specified item slot.", ["String slot"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("disableWornArmor", "Set whether the npc should not gain status effects from the equipped armor. Armor will still be visually equipped.", ["bool disable"], {}, "void"));
tmpClass.methods.push(new LuaMethod("beginPrimaryFire", "Toggles on firing the item equipped in the primary item slot.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("beginAltFire", "Toggles on firing the item equipped in the alt item slot.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("endPrimaryFire", "Toggles off firing the item equipped in the primary item slot.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("endAltFire", "Toggles off firing the item equipped in the alt item slot.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("setShifting", "Sets whether tools should be used as though shift is held.", ["bool shifting"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageOnTouch", "Sets whether damage on touch should be enabled.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("aimPosition", "Returns the current aim position in world space.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("setAimPosition", "Sets the aim position in world space.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDeathParticleBurst", "Sets a particle emitter to burst when the npc dies.", ["String emitter"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setStatusText", "Sets the text to appear above the npc when it first appears on screen.", ["String status"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDisplayNametag", "Sets whether the nametag should be displayed above the NPC.", ["bool display"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPersistent", "Sets whether this npc should persist after being unloaded.", ["bool persistent"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setKeepAlive", "Sets whether to keep this npc alive. If true, the npc will never be unloaded as long as the world is loaded.", ["bool keepAlive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageTeam", "Sets a damage team for the npc in the format: {type = \"enemy\", team = 2}", ["Json damageTeam"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAggressive", "Sets whether the npc should be flagged as aggressive.", ["bool aggressive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setUniqueId", "Sets a unique ID for this npc that can be used to access it. A unique ID has to be unique for the world the npc is on, but not universally unique.", ["String uniqueId"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("object", "The object table contains bindings specific to objects which are available in addition to their common tables.");
tmpClass.methods.push(new LuaMethod("name", "Returns the object's type name.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("direction", "Returns the object's facing direction. This will be 1 for right or -1 for left.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("position", "Returns the object's tile position. This is identical to entity.position(), so use that instead.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("setInteractive", "Sets whether the object is currently interactive.", ["bool interactive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("uniqueId", "Returns the object's unique entity id, or nil if no unique id is set. This should be identical to entity.uniqueId(), so use that instead.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("setUniqueId", "Sets the objects unique entity id, or clears it if unspecified.", ["[String uniqueId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("boundBox", "Returns the object's metaBoundBox in world space.", [], {}, "RectF"));
tmpClass.methods.push(new LuaMethod("spaces", "Returns a list of the tile spaces that the object occupies.", [], {}, "List<Vec2I>"));
tmpClass.methods.push(new LuaMethod("setProcessingDirectives", "Sets the image processing directives that should be applied to the object's animation.", ["String directives"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setSoundEffectEnabled", "Enables or disables the object's persistent sound effect, if one is configured.", ["bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("smash", "Breaks the object. If smash is true then it will be smashed, causing it to (by default) drop no items.", ["[bool smash]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("level", "Returns the \"level\" parameter if set, otherwise returns the current world's threat level.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("toAbsolutePosition", "Returns an absolute world position calculated from the given relative position.", ["Vec2F relativePosition"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("say", "Causes the object to say the line, optionally replacing any specified tags in the text, and using the provided additional chat configuration. Returns true if anything is said (i.e. the line is not empty) and false otherwise.", ["String line", "[Map<String, String> tags]", "[Json config]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("sayPortrait", "Similar to object.say, but uses a portrait chat bubble with the specified portrait image.", ["String line", "String portrait", "[Map<String, String> tags]", "[Json config]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isTouching", "Returns true if the specified entity's collision area overlaps the object's bound box and false otherwise.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setLightColor", "Sets the color of light for the object to emit. This is not the same as animator.setLightColor and the animator light configuration should be used for more featureful light sources.", ["Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getLightColor", "Returns the object's currently configured light color.", [], {}, "Color"));
tmpClass.methods.push(new LuaMethod("inputNodeCount", "Returns the number of wire input nodes the object has.", [], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("outputNodeCount", "Returns the number of wire output nodes the object has.", [], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("getInputNodePosition", "Returns the relative position of the specified wire input node.", ["unsigned nodeIndex"], {}, "Vec2I"));
tmpClass.methods.push(new LuaMethod("getOutputNodePosition", "Returns the relative position of the specified wire output node.", ["unsigned nodeIndex"], {}, "Vec2I"));
tmpClass.methods.push(new LuaMethod("getInputNodeLevel", "Returns the current level of the specified wire input node.", ["unsigned nodeIndex"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("getOutputNodeLevel", "Returns the current level of the specified wire output node.", ["unsigned nodeIndex"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isInputNodeConnected", "Returns true if any wires are currently connected to the specified wire input node and false otherwise.", ["unsigned nodeIndex"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isOutputNodeConnected", "Returns true if any wires are currently connected to the specified wire output node and false otherwise", ["unsigned nodeIndex"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("getInputNodeIds", "Returns a map of the entity id of each wire entity connected to the given wire input node and the index of that entity's output node to which the input node is connected.", ["unsigned nodeIndex"], {}, "Map<EntityId,unsigned>"));
tmpClass.methods.push(new LuaMethod("getOutputNodeIds", "Returns a map of the entity id of each wire entity connected to the given wire output node and the index of that entity's input node to which the output node is connected.", ["unsigned nodeIndex"], {}, "Map<EntityId,unsigned>"));
tmpClass.methods.push(new LuaMethod("setOutputNodeLevel", "Sets the level of the specified wire output node.", ["unsigned nodeIndex", "bool level"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAllOutputNodes", "Sets the level of all wire output nodes.", ["bool level"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setOfferedQuests", "Sets the list of quests that the object will offer to start, or clears them if unspecified.", ["[JsonArray quests]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setTurnInQuests", "Sets the list of quests that the object will accept turn-in for, or clears them if unspecified.", ["[JsonArray quests]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setConfigParameter", "Sets the specified override configuration parameter for the object.", ["String key", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setAnimationParameter", "Sets the specified animation parameter for the object's scripted animator.", ["String key", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setMaterialSpaces", "Sets the object's material spaces to the specified list, or clears them if unspecified. List entries should be in the form of pair<Vec2I, String> specifying the relative position and material name of materials to be set. __Objects should only set material spaces within their occupied tile spaces to prevent Bad Things TM from happening.__", ["[JsonArray spaces]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageSources", "Sets the object's active damage sources (or clears them if unspecified).", ["[List<DamageSource> damageSources]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("health", "Returns the object's current health.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("setHealth", "Sets the object's current health.", ["float health"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("objectAnimator", "The objectAnimator table contains bindings available to client-side animation scripts for objects.");
tmpClass.methods.push(new LuaMethod("getParameter", "Returns the value for the specified object parameter. If there is no value set, returns the default.", ["String parameter", "Json default"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("direction", "Returns the object's facing direction. This will be 1 for right or -1 for left.", [], {}, "int"));
tmpClass.methods.push(new LuaMethod("position", "Returns the object's tile position.", [], {}, "Vec2F"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("physics", "The physics table is available to objects and used to control any collisions or force regions configured on those objects.");
tmpClass.methods.push(new LuaMethod("setForceEnabled", "Enables or disables the specified physics force region.", ["String force", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCollisionPosition", "Moves the specified physics collision region to the specified position.", ["String collision", "Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCollisionEnabled", "Enables or disables the specified physics collision region.", ["String collision", "bool enabled"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("player", "The player table contains functions with privileged access to the player which run in a few contexts on the client such as scripted interface panes, quests, and player companions.");
tmpClass.methods.push(new LuaMethod("id", "Returns the player's entity id.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("uniqueId", "Returns the player's unique id.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("species", "Returns the player's species.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("gender", "Returns the player's gender.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("isAdmin", "Returns whether the player is admin.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("interact", "Triggers an interact action on the player as if they had initiated an interaction and the result had returned the specified interaction type and configuration. Can be used to e.g. open GUI windows normally triggered by player interaction with entities.", ["String interactionType", "Json config", "[EntityId sourceEntityId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("shipUpgrades", "Returns a JSON object containing information about the player's current ship upgrades including \"shipLevel\", \"maxFuel\", \"crewSize\" and a list of \"capabilities\".", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("upgradeShip", "Applies the specified ship upgrades to the player's ship.", ["Json shipUpgrades"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setUniverseFlag", "Sets the specified universe flag on the player's current universe.", ["String flagName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("giveBlueprint", "Teaches the player any recipes which can be used to craft the specified item.", ["ItemDecriptor item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("blueprintKnown", "Returns true if the player knows one or more recipes to create the specified item and false otherwise.", ["ItemDecriptor item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("makeTechAvailable", "Adds the specified tech to the player's list of available (unlockable) techs.", ["String tech"], {}, "void"));
tmpClass.methods.push(new LuaMethod("makeTechUnavailable", "Removes the specified tech from player's list of available (unlockable) techs.", ["String tech"], {}, "void"));
tmpClass.methods.push(new LuaMethod("enableTech", "Unlocks the specified tech, allowing it to be equipped through the tech GUI.", ["String tech"], {}, "void"));
tmpClass.methods.push(new LuaMethod("equipTech", "Equips the specified tech.", ["String tech"], {}, "void"));
tmpClass.methods.push(new LuaMethod("unequipTech", "Unequips the specified tech.", ["String tech"], {}, "void"));
tmpClass.methods.push(new LuaMethod("availableTechs", "Returns a list of the techs currently available to the player.", [], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("enabledTechs", "Returns a list of the techs currently unlocked by the player.", [], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("equippedTech", "Returns the name of the tech the player has currently equipped in the specified slot, or nil if no tech is equipped in that slot.", ["String slot"], {}, "String"));
tmpClass.methods.push(new LuaMethod("currency", "Returns the player's current total reserves of the specified currency.", ["String currencyName"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("addCurrency", "Increases the player's reserve of the specified currency by the specified amount.", ["String currencyName", "unsigned amount"], {}, "void"));
tmpClass.methods.push(new LuaMethod("consumeCurrency", "Attempts to consume the specified amount of the specified currency and returns true if successful and false otherwise.", ["String currencyName", "unsigned amount"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("cleanupItems", "Triggers an immediate cleanup of the player's inventory, removing item stacks with 0 quantity. May rarely be required in special cases of making several sequential modifications to the player's inventory within a single tick.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("giveItem", "Adds the specified item to the player's inventory.", ["ItemDescriptor item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("hasItem", "Returns true if the player's inventory contains an item matching the specified descriptor and false otherwise. If exactMatch is true then parameters as well as item name must match.", ["ItemDescriptor item", "[bool exactMatch]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("hasCountOfItem", "Returns the total number of items in the player's inventory matching the specified descriptor. If exactMatch is true then parameters as well as item name must match.", ["ItemDescriptor item", "[bool exactMatch]"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("consumeItem", "Attempts to consume the specified item from the player's inventory and returns the item consumed if successful. If consumePartial is true, matching stacks totalling fewer items than the requested count may be consumed, otherwise the operation will only be performed if the full count can be consumed. If exactMatch is true then parameters as well as item name must match.", ["ItemDescriptor item", "[bool consumePartial]", "[bool exactMatch]"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("inventoryTags", "Returns a summary of all tags of all items in the player's inventory. Keys in the returned map are tag names and their corresponding values are the total count of items including that tag.", [], {}, "Map<String,unsigned>"));
tmpClass.methods.push(new LuaMethod("itemsWithTag", "Returns a list of ItemDescriptors for all items in the player's inventory that include the specified tag.", ["String tag"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("consumeTaggedItem", "Consumes items from the player's inventory that include the matching tag, up to the specified count of items.", ["String tag", "unsigned count"], {}, "void"));
tmpClass.methods.push(new LuaMethod("hasItemWithParameter", "Returns true if the player's inventory contains at least one item which has the specified parameter set to the specified value.", ["String parameter", "Json value"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("consumeItemWithParameter", "Consumes items from the player's inventory that have the specified parameter set to the specified value, upt to the specified count of items.", ["String parameter", "Json value", "unsigned count"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getItemWithParameter", "Returns the first item in the player's inventory that has the specified parameter set to the specified value, or nil if no such item is found.", ["String parameter", "Json value"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("primaryHandItem", "Returns the player's currently equipped primary hand item, or nil if no item is equipped.", [], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("altHandItem", "Returns the player's currently equipped alt hand item, or nil if no item is equipped.", [], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("primaryHandItemTags", "Returns a list of the tags on the currently equipped primary hand item, or nil if no item is equipped.", [], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("altHandItemTags", "Returns a list of the tags on the currently equipped alt hand item, or nil if no item is equipped.", [], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("essentialItem", "Returns the contents of the specified essential slot, or nil if the slot is empty. Essential slot names are \"beamaxe\", \"wiretool\", \"painttool\" and \"inspectiontool\".", ["String slotName"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("giveEssentialItem", "Sets the contents of the specified essential slot to the specified item.", ["String slotName", "ItemDescriptor item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("removeEssentialItem", "Removes the essential item in the specified slot.", ["String slotName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("equippedItem", "Returns the contents of the specified equipment slot, or nil if the slot is empty. Equipment slot names are \"head\", \"chest\", \"legs\", \"back\", \"headCosmetic\", \"chestCosmetic\", \"legsCosmetic\" and \"backCosmetic\".", ["String slotName"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("setEquippedItem", "Sets the item in the specified equipment slot to the specified item.", ["String slotName", "Json item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("swapSlotItem", "Returns the contents of the player's swap (cursor) slot, or nil if the slot is empty.", [], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("setSwapSlotItem", "Sets the item in the player's swap (cursor) slot to the specified item.", ["Json item"], {}, "void"));
tmpClass.methods.push(new LuaMethod("canStartQuest", "Returns true if the player meets all of the prerequisites to start the specified quest and false otherwise.", ["Json questDescriptor"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("startQuest", "Starts the specified quest, optionally using the specified server Uuid and world id, and returns the quest id of the started quest.", ["Json questDescriptor", "[String serverUuid]", "[String worldId]"], {}, "QuestId"));
tmpClass.methods.push(new LuaMethod("hasQuest", "Returns true if the player has a quest, in any state, with the specified quest id and false otherwise.", ["String questId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("hasCompletedQuest", "Returns true if the player has a completed quest with the specified quest id and false otherwise.", ["String questId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("enableMission", "Adds the specified mission to the player's list of available missions.", ["String missionName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("completeMission", "Adds the specified mission to the player's list of completed missions.", ["String missionName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("radioMessage", "Triggers the specified radio message for the player, either immediately or with the specified delay.", ["Json messageConfig", "[float delay]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("worldId", "Returns a String representation of the world id of the player's current world.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("serverUuid", "Returns a String representation of the player's Uuid on the server.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("ownShipWorldId", "Returns a String representation of the world id of the player's ship world.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("lounge", "Triggers the player to lounge in the specified loungeable entity at the specified lounge anchor index (default is 0).", ["EntityId loungeableId", "[unsigned anchorIndex]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isLounging", "Returns true if the player is currently occupying a loungeable entity and false otherwise.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("loungingIn", "If the player is currently lounging, returns the entity id of what they are lounging in.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("playTime", "Returns the total played time for the player.", [], {}, "double"));
tmpClass.methods.push(new LuaMethod("introComplete", "Returns true if the player is marked as having completed the intro instance and false otherwise.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setIntroComplete", "Sets whether the player is marked as having completed the intro instance.", ["bool complete"], {}, "void"));
tmpClass.methods.push(new LuaMethod("warp", "Immediately warps the player to the specified warp target, optionally using the specified warp animation and deployment.", ["String warpAction", "[String animation]", "[bool deploy]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("canDeploy", "Returns whether the player has a deployable mech.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isDeployed", "Returns whether the player is currently deployed.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("confirm", "Displays a confirmation dialog to the player with the specified dialog configuration and returns an RpcPromise which can be used to retrieve the player's response to that dialog.", ["Json dialogConfig"], {}, "RpcPromise"));
tmpClass.methods.push(new LuaMethod("playCinematic", "Triggers the specified cinematic to be displayed for the player. If unique is true the cinematic will only be shown to that player once.", ["Json cinematic", "[bool unique]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("recordEvent", "Triggers the specified event on the player with the specified fields. Used to record data e.g. for achievements.", ["String event", "Json fields"], {}, "void"));
tmpClass.methods.push(new LuaMethod("worldHasOrbitBookmark", "Returns whether the player has a bookmark for the specified celestial coordinate.", ["Json coordinate"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("orbitBookmarks", "Returns a list of orbit bookmarks with their system coordinates.", [], {}, "List<pair<Vec3I,Json>>"));
tmpClass.methods.push(new LuaMethod("systemBookmarks", "Returns a list of orbit bookmarks in the specified system.", ["Json systemCoordinate"], {}, "List<Json>"));
tmpClass.methods.push(new LuaMethod("addOrbitBookmark", "Adds the specified bookmark to the player's bookmark list and returns true if the bookmark was successfully added (and was not already known) and false otherwise.", ["Json systemCoordinate", "Json bookmarkConfig"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("removeOrbitBookmark", "Removes the specified bookmark from the player's bookmark list and returns true if the bookmark was successfully removed and false otherwise.", ["Json systemCoordinate", "Json bookmarkConfig"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("addTeleportBookmark", "Adds the specified bookmark to the player's bookmark list and returns true if the bookmark was successfully added (and was not already known) and false otherwise.", ["Json bookmarkConfig"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isMapped", "Returns whether the player has previously visited the specified coordinate.", ["Json coordinate"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("mappedObjects", "Returns uuid, type, and orbits for all system objects in the specified system;", ["Json systemCoordinate"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("collectables", "Returns a list of names of the collectables the player has unlocked in the specified collection.", ["String collectionName"], {}, "List<String>"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("playerCompanions", "The playerCompanions table contains bindings used to manage player companions such as pets and crew members.");
tmpClass.methods.push(new LuaMethod("getCompanions", "Returns a list of configurations for all companions of the specified type.", ["String companionType"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("setCompanions", "Sets the player's companions of the specified type to the specified list of companion configurations.", ["String companionType", "JsonArray companions"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("projectile", "The projectile table contains bindings specific to projectiles which are available in addition to their common tables.");
tmpClass.methods.push(new LuaMethod("getParameter", "Returns the value for the specified config parameter. If there is no value set, returns the default.", ["String parameter", "Json default"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("die", "Destroys the projectile.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("sourceEntity", "Returns the entity id of the projectile's source entity, or nil if no source entity is set.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("powerMultiplier", "Returns the projectile's power multiplier.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("power", "Returns the projectile's power (damage).", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("setPower", "Sets the projectile's power (damage).", ["float power"], {}, "void"));
tmpClass.methods.push(new LuaMethod("timeToLive", "Returns the projectile's current remaining time to live.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("setTimeToLive", "Sets the projectile's current remaining time to live. Altering the time to live may cause visual disparity between the projectile's master and slave entities.", ["float timeToLive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("collision", "Returns true if the projectile has collided and false otherwise.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("processAction", "Immediately performs the specified action. Action should be specified in a format identical to a single entry in e.g. actionOnReap in the projectile's configuration. This function will not properly perform rendering actions as they will not be networked.", ["Json action"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setReferenceVelocity", "Sets the projectile's reference velocity (a base velocity to which movement is relative)", ["Maybe<Vec2F> velocity"], {}, "'void'"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("quest", "The `quest` table contains functions relating directly to the quest whose script its run in.");
tmpClass.methods.push(new LuaMethod("state", "Returns the current state of the quest.\n\nPossible states:\n* \"New\"\n* \"Offer\"\n* \"Active\"\n* \"Complete\"\n* \"Failed\"", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("complete", "Immediately completes the quest.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("fail", "Immediately fails the quest.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCanTurnIn", "Sets whether the quest can be turned in.", ["bool turnIn"], {}, "void"));
tmpClass.methods.push(new LuaMethod("questId", "Returns the quest id.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("templateId", "Returns the ID of the template used to make this quest.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("seed", "Returns the seed used to generate the quest.", [], {}, "uint64_t"));
tmpClass.methods.push(new LuaMethod("questDescriptor", "Returns the quest descriptor including parameters.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("questArcDescriptor", "Returns the quest arc descriptor.", [], {}, "Json"));
tmpClass.methods.push(new LuaMethod("questArcPosition", "Returns the quest arc position. (?)", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("worldId", "Returns the world id for the quest arc.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("serverUuid", "Returns the server uuid for the quest.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("parameters", "Returns all quest parameters.", [], {}, "QuestParameters"));
tmpClass.methods.push(new LuaMethod("setParameter", "Sets a quest parameter.", ["String name", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setIndicators", "Set a list of quest parameters to use as custom indicators.", ["List<String> indicators"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setObjectiveList", "Set the objectives for the quest tracker. Objectives are in the format {text, completed}", ["JsonArray objectives"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setProgress", "Sets the progress amount of the quest tracker progress bar. Set nil to hide. Progress is from 0.0 to 1.0.", ["float progress"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCompassDirection", "Set the angle of the quest tracker compass. Setting nil hides the compass.", ["float angle"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setTitle", "Sets the title of the quest in the quest log.", ["String title"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setText", "Set the text for the quest in the quest log.", ["String text"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setCompletionText", "Sets the text shown in the completion window when the quest is completed.", ["String completionText"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setFailureText", "Sets the text shown in the completion window when the quest is failed.", ["String failureText"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPortrait", "Sets a portrait to a list of drawables.", ["String portraitName", "JsonArray portrait"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPortraitTitle", "Sets a portrait title.", ["String portraitName", "String title"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addReward", "Add an item to the reward pool.", ["ItemDescriptor reward"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("root", "The `root` table contains functions that reference the game's currently loaded assets and don't relate to any more specific context such as a particular world or universe.");
tmpClass.methods.push(new LuaMethod("assetJson", "Returns the contents of the specified JSON asset file.", ["String assetPath"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("makeCurrentVersionedJson", "Returns a versioned JSON representation of the given JSON content with the given identifier and the most recent version as specified in versioning.config.", ["String versioningIdentifier", "Json content"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("loadVersionedJson", "Returns the given JSON content and identifier after applying appropriate versioning scripts to bring it up to the most recent version as specified in versioning.config.", ["Json versionedContent", "String versioningIdentifier"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("evalFunction", "Returns the evaluation of the specified univariate function (as defined in a .functions file) for the given input value.", ["String functionName", "double input"], {}, "double"));
tmpClass.methods.push(new LuaMethod("evalFunction2", "Returns the evaluation of the specified bivariate function (as defined in a .2functions file) for the given input values.", ["String functionName", "double input1", "double input2"], {}, "double"));
tmpClass.methods.push(new LuaMethod("imageSize", "Returns the pixel dimensions of the specified image asset.", ["String imagePath"], {}, "Vec2U"));
tmpClass.methods.push(new LuaMethod("imageSpaces", "Returns a list of the world tile spaces the image would occupy if placed at the given position using the specified spaceScan value (the portion of a space that must be non-transparent for that space to count as filled).", ["String imagePath", "Vec2F worldPosition", "float spaceScan", "bool flip"], {}, "List<Vec2I>"));
tmpClass.methods.push(new LuaMethod("nonEmptyRegion", "Returns the rectangle containing the portion of the specified asset image that is non-transparent.", ["String imagePath"], {}, "RectU"));
tmpClass.methods.push(new LuaMethod("npcConfig", "Returns a representation of the generated JSON configuration for an NPC of the given type.", ["String npcType"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("npcVariant", "Generates an NPC with the specified species, type, level, seed and parameters, and returns its configuration.", ["String species", "String npcType", "float level", "[unsigned seed]", "[Json parameters]"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("projectileGravityMultiplier", "Returns the gravity multiplier of the given projectile's movement controller configuration as configured in physics.config.", ["String projectileName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("projectileConfig", "Returns a representation of the JSON configuration for the given projectile.", ["String projectileName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("itemDescriptorsMatch", "Returns true if the given item descriptors match. If exactMatch is true then both names and parameters will be compared, otherwise only names.", ["ItemDescriptor descriptor1", "ItemDescriptor descriptor2", "[bool exactMatch]"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("recipesForItem", "Returns a list of JSON configurations of all recipes which output the given item.", ["String itemName"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("itemType", "Returns the item type name for the specified item.", ["String itemName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("itemTags", "Returns a list of the tags applied to the specified item.", ["String itemName"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("itemHasTag", "Returns true if the given item's tags include the specified tag and false otherwise.", ["String itemName", "String tagName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("itemConfig", "Generates an item from the specified descriptor, level and seed and returns a JSON object containing the directory, config and parameters for that item.", ["ItemDescriptor descriptor", "[float level]", "[unsigned seed]"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("createItem", "Generates an item from the specified descriptor, level and seed and returns a new item descriptor for the resulting item.", ["ItemDescriptor descriptor", "[float level]", "[unsigned seed]"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("tenantConfig", "Returns the JSON configuration for the given tenant.", ["String tenantName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("getMatchingTenants", "Returns an array of JSON configurations of tenants matching the given map of colony tags and corresponding object counts.", ["map<String, unsigned> colonyTags"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("liquidStatusEffects", "Returns an array of status effects applied by the given liquid.", ["LiquidId liquid"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("generateName", "Returns a randomly generated name using the specified name gen config and seed.", ["String assetPath", "[unsigned seed]"], {}, "String"));
tmpClass.methods.push(new LuaMethod("questConfig", "Returns the JSON configuration of the specified quest template.", ["String questTemplateId"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("npcPortrait", "Generates an NPC with the specified type, level, seed and parameters and returns a portrait in the given portraitMode as a list of drawables.", ["String portraitMode", "String species", "String npcType", "float level", "[unsigned seed]", "[Json parameters]"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("monsterPortrait", "Generates a monster of the given type with the given parameters and returns its portrait as a list of drawables.", ["String typeName", "[Json parameters]"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("isTreasurePool", "Returns true if the given treasure pool exists and false otherwise. Can be used to guard against errors attempting to generate invalid treasure.", ["String poolName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("createTreasure", "Generates an instance of the specified treasure pool, level and seed and returns the contents as a list of item descriptors.", ["String poolName", "float level", "[unsigned seed]"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("materialMiningSound", "Returns the path of the mining sound asset for the given material and mod combination, or nil if no mining sound is set.", ["String materialName", "[String modName]"], {}, "String"));
tmpClass.methods.push(new LuaMethod("materialFootstepSound", "Returns the path of the footstep sound asset for the given material and mod combination, or nil if no footstep sound is set.", ["String materialName", "[String modName]"], {}, "String"));
tmpClass.methods.push(new LuaMethod("materialHealth", "Returns the configured health value for the specified material.", ["String materialName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("materialConfig", "Returns a JSON object containing the path and base config for the specified material if it is a real material, or nil if it is a metamaterial or invalid.", ["String materialName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("modConfig", "Returns a JSON object containing the path and base config for the specified mod if it is a real mod, or nil if it is a metamod or invalid.", ["String modName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("liquidConfig", "Returns a JSON object containing the path and base config for the specified liquid name or id if it is a real liquid, or nil if the liquid is empty or invalid.", ["LiquidId/String liquidId"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("liquidName", "Returns the string name of the liquid with the given ID.", ["LiquidId liquidId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("liquidId", "Returns the numeric ID of the liquid with the given name.", ["String liquidName"], {}, "LiquidId"));
tmpClass.methods.push(new LuaMethod("monsterSkillParameter", "Returns the value of the specified parameter for the specified monster skill.", ["String skillName", "String parameterName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("monsterParameters", "Returns the parameters for a monster type.", ["String monsterType"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("monsterMovementSettings", "Returns the configured base movement parameters for the specified monster type.", ["String monsterType"], {}, "ActorMovementParameters"));
tmpClass.methods.push(new LuaMethod("createBiome", "Generates a biome with the specified name, seed, vertical midpoint and threat level, and returns a JSON object containing the configuration for the generated biome.", ["String biomeName", "unsigned seed", "float verticalMidPoint", "float threatLevel"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("hasTech", "Returns true if a tech with the specified name exists and false otherwise.", ["String techName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("techType", "Returns the type (tech slot) of the specified tech.", ["String techName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("techConfig", "Returns the JSON configuration for the specified tech.", ["String techName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("treeStemDirectory", "Returns the path within assets from which the specified tree stem type was loaded.", ["String stemName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("treeFoliageDirectory", "Returns the path within assets from which the specified tree foliage type was loaded.", ["String foliageName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("collection", "Returns the metadata for the specified collection.", ["String collectionName"], {}, "Collection"));
tmpClass.methods.push(new LuaMethod("collectables", "Returns a list of collectables for the specified collection.", ["String collectionName"], {}, "List<Collectable>"));
tmpClass.methods.push(new LuaMethod("elementalResistance", "Returns the name of the stat used to calculate elemental resistance for the specified elemental type.", ["String elementalType"], {}, "String"));
tmpClass.methods.push(new LuaMethod("dungeonMetadata", "Returns the metadata for the specified dungeon definition.", ["String dungeonName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("behavior", "Loads a behavior and returns the behavior state as userdata.\n\ncontext is the current lua context called from, in almost all cases _ENV.\n\nconfig can be either the String name of a behavior tree, or an entire behavior tree configuration to be built.\n\nparameters is overrides for parameters for the behavior tree.\n\nBehaviorState contains 2 methods:\n\nbehavior:init(_ENV) -- initializes the behavior, loads required scripts, and returns a new behavior state\nbehavior:run(state, dt) -- runs the behavior, takes a behavior state for the first argument\nbehavior:clear(state) -- resets the internal state of the behavior", ["LuaTable context", "Json config", "JsonObject parameters"], {}, "BehaviorState"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("animationConfig", "The `animationConfig` table contains functions for getting configuration options from the base entity and its networked animator.");
tmpClass.methods.push(new LuaMethod("animationParameter", "Returns a networked value set by the parent entity's master script.", ["String key"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("partPoint", "Returns a Vec2F configured in a part's properties with all of the part's transformations applied to it.", ["String partName", "String propertyName"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("partPoly", "Returns a PolyF configured in a part's properties with all the part's transformations applied to it.", ["String partName", "String propertyName"], {}, "PolyF"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("pane", "These pane bindings are available to scripted interface panes and include functions not specifically related to widgets within the pane.");

tmpClass = new LuaClass("stagehand", "The stagehand table contains bindings specific to stagehands which are available in addition to their common tables.");
tmpClass.methods.push(new LuaMethod("id", "Returns the stagehand's entity id. Identical to entity.id(), so use that instead.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("position", "Returns the stagehand's position. This is identical to entity.position(), so use that instead.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("setPosition", "Moves the stagehand to the specified position.", ["Vec2F position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("die", "Destroys the stagehand.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("typeName", "Returns the stagehand's type name.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("setUniqueId", "Sets the stagehand's unique entity id, or clears it if unspecified.", ["[String uniqueId]"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("status", "The `status` table relates to the status controller attached to an entity. It is available in:\n\n* monsters\n* npcs\n* status effects\n* companion system scripts\n* quest scripts\n* tech\n* primary status scripts for: player, monster, npc");
tmpClass.methods.push(new LuaMethod("statusProperty", "Returns the value assigned to the specified status property. If there is no value set, returns default.", ["String name", "Json default"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("setStatusProperty", "Sets a status property to the specified value.", ["String name", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("stat", "Returns the value for the specified stat. Defaults to 0.0 if the stat does not exist.", ["String statName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("statPositive", "Returns whether the stat value is greater than 0.", ["String statName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("resourceNames", "Returns a list of the names of all the configured resources;", [], {}, "List<String>"));
tmpClass.methods.push(new LuaMethod("isResource", "Returns whether the specified resource exists in this status controller.", ["String resourceName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("resource", "Returns the value of the specified resource.", ["String resourceName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("resourcePositive", "Returns whether the value of the specified resource is greater than 0.", ["String resourceName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setResource", "Sets a resource to the specified value.", ["String resourceName", "float value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("modifyResource", "Adds the specified value to a resource.", ["String resourceName", "float value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("giveResource", "Adds the specified value to a resource. Returns any overflow.", ["String resourceName", "float value"], {}, "float"));
tmpClass.methods.push(new LuaMethod("consumeResource", "Tries to consume the specified amount from a resource. Returns whether the full amount was able to be consumes. Does not modify the resource if unable to consume the full amount.", ["String resourceName", "float amount"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("overConsumeResource", "Tries to consume the specified amount from a resource. If unable to consume the full amount, will consume all the remaining amount. Returns whether it was able to consume any at all of the resource.", ["String resourceName", "float amount"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("resourceLocked", "Returns whether the resource is currently locked.", ["String resourceName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setResourceLocked", "Sets a resource to be locked/unlocked. A locked resource cannot be consumed.", ["String resourceName", "bool locked"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetResource", "Resets a resource to its base value.", ["String resourceName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("resetAllResources", "Resets all resources to their base values.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("resourceMax", "Returns the max value for the specified resource.", ["String resourceName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("resourcePercentage", "Returns the percentage of max that the resource is currently at. From 0.0 to 1.0.", ["String resourceName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("setResourcePercentage", "Sets a resource to a percentage of the max value for the resource. From 0.0 to 1.0.", ["String resourceName", "float value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("modifyResourcePercentage", "Adds a percentage of the max resource value to the current value of the resource.", ["String resourceName", "float value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getPersistentEffects", "Returns a list of the currently active persistent effects in the specified effect category.", ["String effectCategory"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("addPersistentEffect", "Adds a status effect to the specified effect category.", ["String effectCategory", "Json effect"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addPersistentEffects", "Adds a list of effects to the specified effect category.", ["String effectCategory", "JsonArray effects"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPersistentEffects", "Sets the list of effects of the specified effect category. Replaces the current list active effects.", ["String effectCategory", "JsonArray effects"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearPersistentEffects", "Clears any status effects from the specified effect category.", ["String effectCategory"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearAllPersistentEffects", "Clears all persistent status effects from all effect categories.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("addEphemeralEffect", "Adds the specified unique status effect. Optionally with a custom duration, and optionally with a source entity id accessible in the status effect.", ["String effectName", "[float duration]", "[EntityId sourceEntity]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addEphemeralEffects", "Adds a list of unique status effects. Optionally with a source entity id.\n\nUnique status effects can be specified either as a string, \"myuniqueeffect\", or as a table, {effect = \"myuniqueeffect\", duration = 5}. Remember that this function takes a list of these effect descriptors. This is a valid list of effects: { \"myuniqueeffect\", {effect = \"myothereffect\", duration = 5} }", ["JsonArray effects", "[EntityId sourceEntity]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("removeEphemeralEffect", "Removes the specified unique status effect.", ["String effectName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearEphemeralEffects", "Clears all ephemeral status effects.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("damageTakenSince", "Returns two values:\n* A list of damage notifications for the entity's damage taken since the specified heartbeat.\n* The most recent heartbeat to be passed into the function again to get the damage notifications taken since this function call.", ["[unsigned since = 0]]"], {}, "List<pair<DamageNotification>>,unsigned"));
tmpClass.methods.push(new LuaMethod("inflictedHitsSince", "Returns two values:\n* A list {{entityId, damageRequest}} for the entity's inflicted hits since the specified heartbeat.\n* The most recent heartbeat to be passed into the function again to get the inflicted hits since this function call.", ["[unsigned since = 0]]"], {}, "List<pair<EntityId,DamageRequest>>,unsigned"));
tmpClass.methods.push(new LuaMethod("inflictedDamageSince", "Returns two values:\n* A list of damage notifications for damage inflicted by the entity.\n* The most recent heartbeat to be passed into the function again to get the list of damage notifications since the last call.", ["[unsigned since = 0]"], {}, "List<DamageNotification>,unsigned"));
tmpClass.methods.push(new LuaMethod("activeUniqueStatusEffectSummary", "Returns a list of two element tables describing all unique status effects currently active on the status controller. Each entry consists of the String name of the effect and a float between 0 and 1 indicating the remaining portion of that effect's duration.", [], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("primaryDirectives", "Returns the primary set of image processing directives applied to the animation of the entity using this status controller.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("setPrimaryDirectives", "Sets the primary set of image processing directives that should be applied to the animation of the entity using this status controller.", ["[String directives]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("applySelfDamageRequest", "Directly applies the specified damage request to the entity using this status controller.", ["DamageRequest damageRequest"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("effect", "The `effect` table relates to functions specifically for status effects.");
tmpClass.methods.push(new LuaMethod("duration", "Returns the remaining duration of the status effect.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("modifyDuration", "Adds the specified duration to the current remaining duration.", ["float duration"], {}, "void"));
tmpClass.methods.push(new LuaMethod("expire", "Immediately expire the effect, setting the duration to 0.", [], {}, "void"));
tmpClass.methods.push(new LuaMethod("sourceEntity", "Returns the source entity id of the status effect, if any.", [], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("setParentDirectives", "Sets image processing directives for the entity the status effect is active on.", ["String directives"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getParameter", "Returns the value associated with the parameter name in the effect configuration. If no value is set, returns the default specified.", ["String name", "Json def"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("addStatModifierGroup", "Adds a new stat modifier group and returns the ID created for the group. Stat modifier groups will stay active until the effect expires.", ["List<StatModifier> modifiers"], {}, "StatModifierGroupId"));
tmpClass.methods.push(new LuaMethod("setStatModifierGroup", "Replaces the list of stat modifiers in a group with the specified modifiers.", ["StatModifierGroupId, groupId", "List<StatModifier> modifiers"], {}, "void"));
tmpClass.methods.push(new LuaMethod("removeStatModifierGroup", "Removes the specified stat modifier group.", ["StatModifierGroupId groupId"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("tech", "The `tech` table contains functions exclusively available in tech scripts.");
tmpClass.methods.push(new LuaMethod("aimPosition", "Returns the current cursor aim position.", [], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("setVisible", "Sets whether the tech should be visible.", ["bool visible"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParentState", "Set the animation state of the player.\n\nValid states:\n* \"Stand\"\n* \"Fly\"\n* \"Fall\"\n* \"Sit\"\n* \"Lay\"\n* \"Duck\"\n* \"Walk\"\n* \"Run\"\n* \"Swim\"", ["String state"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParentDirectives", "Sets the image processing directives for the player.", ["String directives"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParentHidden", "Sets whether to make the player invisible. Will still show the tech.", ["bool hidden"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setParentOffset", "Sets the position of the player relative to the tech.", ["Vec2F offset"], {}, "void"));
tmpClass.methods.push(new LuaMethod("parentLounging", "Returns whether the player is lounging.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setToolUsageSuppressed", "Sets whether to suppress tool usage on the player. When tool usage is suppressed no items can be used.", ["bool suppressed"], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("script", "Most entity script contexts include the *script* table, which provides bindings for getting and setting the script's update rate. Update deltas are specified in numbers of frames, so a script with an update delta of 1 would run every frame, or a script with an update delta of 60 would run once per second. An update delta of 0 means that the script's periodic update will never be called, but it can still perform actions through script calls, messaging, or event hooks.");
tmpClass.methods.push(new LuaMethod("setUpdateDelta", "Sets the script's update delta.", ["unsigned dt"], {}, "void"));
tmpClass.methods.push(new LuaMethod("updateDt", "Returns the duration in seconds between periodic updates to the script.", [], {}, "float"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("sb", "The sb table contains miscellaneous utility functions that don't directly relate to any assets or content of the game.");
tmpClass.methods.push(new LuaMethod("nrand", "Returns a randomized value with a normal distribution using the specified standard deviation (default is 1.0) and mean (default is 0).", ["[double standardDeviation]", "[double mean]"], {}, "double"));
tmpClass.methods.push(new LuaMethod("makeUuid", "Returns a String representation of a new, randomly-created Uuid.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("logInfo", "Logs the specified formatted string, optionally using the formatted replacement values, to the log file and console with the Info log level.", ["String formatString", "[LuaValue formatValues ...]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("logWarn", "Logs the specified formatted string, optionally using the formatted replacement values, to the log file and console with the Warn log level.", ["String formatString", "[LuaValue formatValues ...]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("logError", "Logs the specified formatted string, optionally using the formatted replacement values, to the log file and console with the Error log level.", ["String formatString", "[LuaValue formatValues ...]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLogMap", "Sets an entry in the debug log map (visible while in debug mode) using the specified format string and optional formatted replacement values.", ["String key", "String formatString", "[LuaValue formatValues ...]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("printJson", "Returns a human-readable string representation of the specified JSON value. If pretty is true, objects and arrays will have whitespace added for readability.", ["Json value", "[bool pretty]"], {}, "String"));
tmpClass.methods.push(new LuaMethod("print", "Returns a human-readable string representation of the specified LuaValue.", ["LuaValue value"], {}, "String"));
tmpClass.methods.push(new LuaMethod("interpolateSinEase", "Returns an interpolated Vec2F or double between the two specified values using a sin ease function.", ["double offset", "Variant<Vec2F, double> value1", "Variant<Vec2F, double> value2"], {}, "Variant<Vec2F,double>"));
tmpClass.methods.push(new LuaMethod("replaceTags", "Replaces all tags in the specified string with the specified tag replacement values.", ["String string", "Map<String, String> tags"], {}, "String"));
tmpClass.methods.push(new LuaMethod("jsonMerge", "Returns the result of merging the contents of b on top of a.", ["Json a", "Json b"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("jsonQuery", "Attempts to extract the value in the specified content at the specified path, and returns the found value or the specified default if no such value exists.", ["Json content", "String path", "Json default"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("staticRandomI32", "Returns a statically randomized 32-bit signed integer based on the given list of seed values.", ["[LuaValue hashValues ...]"], {}, "int"));
tmpClass.methods.push(new LuaMethod("staticRandomI32Range", "Returns a statically randomized 32-bit signed integer within the specified range based on the given list of seed values.", ["int min", "int max", "[LuaValue hashValues ...]"], {}, "int"));
tmpClass.methods.push(new LuaMethod("staticRandomDouble", "Returns a statically randomized double based on the given list of seed values.", ["[LuaValue hashValues ...]"], {}, "double"));
tmpClass.methods.push(new LuaMethod("staticRandomDoubleRange", "Returns a statically randomized double within the specified range based on the given list of seed values.", ["double min", "double max", "[LuaValue hashValues ...]"], {}, "double"));
tmpClass.methods.push(new LuaMethod("makeRandomSource", "Creates and returns a Lua UserData value which can be used as a random source, initialized with the specified seed. The RandomSource has the following methods:", ["[unsigned seed]"], {}, "RandomSource"));
tmpClass.methods.push(new LuaMethod("makePerlinSource", "Creates and returns a Lua UserData value which can be used as a Perlin noise source. The configuration for the PerlinSource should be a JSON object and can include the following keys", ["Json config"], {}, "PerlinSource"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("vehicle", "The vehicle table contains bindings specific to vehicles which are available in addition to their common tables.");
tmpClass.methods.push(new LuaMethod("controlHeld", "Returns true if the specified control is currently being held by an occupant of the specified lounge position and false otherwise.", ["String loungeName", "String controlName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("aimPosition", "Returns the world aim position for the specified lounge position.", ["String loungeName"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityLoungingIn", "Returns the entity id of the entity currently occupying the specified lounge position, or nil if the lounge position is unoccupied.", ["String loungeName"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("setLoungeEnabled", "Enables or disables the specified lounge position.", ["String loungeName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLoungeOrientation", "Sets the lounge orientation for the specified lounge position. Valid orientations are \"sit\", \"stand\" or \"lay\".", ["String loungeName", "String orientation"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLoungeEmote", "Sets the emote to be performed by entities occupying the specified lounge position, or clears it if no emote is specified.", ["String loungeName", "[String emote]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLoungeDance", "Sets the dance to be performed by entities occupying the specified lounge position, or clears it if no dance is specified.", ["String loungeName", "[String dance]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLoungeStatusEffects", "Sets the list of status effects to be applied to entities occupying the specified lounge position. To clear the effects, set an empty list.", ["String loungeName", "JsonArray statusEffects"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPersistent", "Sets whether the vehicle is persistent, i.e. whether it will be stored when the world is unloaded and reloaded.", ["bool persistent"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setInteractive", "Sets whether the vehicle is currently interactive.", ["bool interactive"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageTeam", "Sets the vehicle's current damage team type and number.", ["DamageTeam team"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setMovingCollisionEnabled", "Enables or disables the specified collision region.", ["String collisionName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setForceRegionEnabled", "Enables or disables the specified force region.", ["String regionName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDamageSourceEnabled", "Enables or disables the specified damage source.", ["String damageSourceName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("destroy", "Destroys the vehicle.", [], {}, "void"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("widget", "The `widget` table contains functions to manipulate and get data about widgets in a scriptpane.\n\nThe widgetName passed into most of these functions can contain period separators for getting children.");
tmpClass.methods.push(new LuaMethod("playSound", "Plays a sound.", ["String audio", "[int loops = 0]", "[float volume = 1.0f]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getPosition", "Returns the position of a widget.", ["String widgetName"], {}, "Vec2I"));
tmpClass.methods.push(new LuaMethod("setPosition", "Sets the position of a widget.", ["String widgetName", "Vec2I position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getSize", "Returns the size of a widget.", ["String widgetName"], {}, "Vec2I"));
tmpClass.methods.push(new LuaMethod("setSize", "Sets the size of a widget.", ["String widgetName", "Vec2I size"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setVisible", "Sets the visibility of a widget.", ["String widgetName", "bool visible"], {}, "void"));
tmpClass.methods.push(new LuaMethod("active", "Returns whether the widget is visible.", ["String widgetName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("focus", "Sets focus on the specified widget.", ["String widgetName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("hasFocus", "Returns whether the specified widget is currently focused.", ["String widgetName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("blur", "Unsets focus on the specified focused widget.", ["String widgetName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getData", "Returns the arbitrary data value set for the widget.", ["String widgetName"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("setData", "Sets arbitrary data for the widget.", ["String widgetName", "Json data"], {}, "void")); tmpClass.methods.push(new LuaMethod("getChildAt", "Returns the full name for any widget at screenPosition.", ["Vec2I screenPosition"], {}, "String"));
tmpClass.methods.push(new LuaMethod("inMember", "Returns whether the widget contains the specified screenPosition.", ["String widgetName", "Vec2I screenPosition"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("getText", "Returns the text set in a TextBoxWidget.", ["String widgetName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("setText", "Sets the text of: LabelWidget, ButtonWidget, TextBoxWidget", ["String widgetName", "String text"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setFontColor", "Sets the font color of: LabelWidget, ButtonWidget, TextBoxWidget", ["String widgetName", "Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setImage", "Sets the image of an ImageWidget.", ["String widgetName", "String imagePath"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setImageScale", "Sets the scale of an ImageWidget.", ["String widgetName", "float imageScale"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setImageRotation", "Sets the rotation of an ImageWidget.", ["String widgetName", "float imageRotation"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setButtonEnabled", "Sets whether the ButtonWidget should be enabled.", ["String widgetName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setButtonImage", "Sets the baseImage of a ButtonWidget.", ["String widgetName", "String baseImage"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setButtonImages", "Sets the full image set of a ButtonWidget.", ["String widgetName", "Json imageSet"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setButtonCheckedImages", "Similar to widget.setButtonImages, but sets the images used for the checked state of a checkable ButtonWidget.", ["String widgetName", "Json imageSet"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setButtonOverlayImage", "Sets the overlay image of a ButtonWidget.", ["String widgetName", "String overlayImage"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getChecked", "Returns whether the ButtonWidget is checked.", ["String widgetName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setChecked", "Sets whether a ButtonWidget is checked", ["String widgetName", "bool checked"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getSelectedOption", "Returns the index of the selected option in a ButtonGroupWidget.", ["String widgetName"], {}, "int"));
tmpClass.methods.push(new LuaMethod("getSelectedData", "Returns the data of the selected option in a ButtonGroupWidget. Nil if no option is selected.", ["String widgetName"], {}, "int"));
tmpClass.methods.push(new LuaMethod("setSelectedOption", "Sets the selected option index of a ButtonGroupWidget.", ["String widgetName", "int index"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setOptionEnabled", "Sets whether a ButtonGroupWidget option should be enabled.", ["String widgetName", "int index", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setOptionVisible", "Sets whether a ButtonGroupWidget option should be visible.", ["String widgetName", "int index", "bool, visible"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setProgress", "Sets the progress of a ProgressWidget. Value should be between 0.0 and 1.0.", ["String widgetName", "float value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setSliderEnabled", "Sets whether the SliderBarWidget should be enabled.", ["String widgetName", "bool enabled"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getSliderValue", "Gets the current value of a SliderBarWidget.", ["String widgetName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("setSliderValue", "Sets the current value of a SliderBarWidget.", ["String widgetName", "int newValue"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getSliderRange", "Sets the minimum, maximum and (optionally) delta values of a SliderBarWidget.", ["String widgetName", "int newMin", "int newMax", "[int newDelta]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("clearListItems", "Clears all items in a ListWidget.", ["String widgetName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addListItem", "Adds a list item to a ListWidget using the configured template, and returns the name of the added list item.", ["String widgetName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("removeListItem", "Removes a list item from a ListWidget at a specific index.", ["String widgetName", "size_t at"], {}, "void"));
tmpClass.methods.push(new LuaMethod("getListSelected", "Returns the name of the currently selected widget in a ListWidget.", ["String widgetName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("setListSelected", "Sets the selected widget of a ListWidget.", ["String widgetName", "String selected"], {}, "void"));
tmpClass.methods.push(new LuaMethod("registerMemberCallback", "Registers a member callback for a ListWidget's list items to use.", ["String widgetName", "String callbackName", "LuaFunction callback"], {}, "void"));
tmpClass.methods.push(new LuaMethod("itemGridItems", "Returns the full item bag contents of an ItemGridWidget.", ["String widgetName"], {}, "ItemBag"));
tmpClass.methods.push(new LuaMethod("itemSlotItem", "Returns the descriptor of the item in the specified item slot widget.", ["String widgetName"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("setItemSlotItem", "Sets the item in the specified item slot widget.", ["String widgetName", "Json itemDescriptor"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setItemSlotProgress", "Sets the progress overlay on the item slot to the specified value (between 0 and 1).", ["String widgetName", "float progress"], {}, "void"));
tmpClass.methods.push(new LuaMethod("bindCanvas", "Binds the canvas widget with the specified name as userdata for easy access. The CanvasWidget has the following methods:", ["String widgetName"], {}, "CanvasWidget"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("world", "The `world` table contains functions that perform actions within a specified such as querying or modifying entities, tiles, etc. in that world.");
tmpClass.methods.push(new LuaMethod("type", "Returns a string describing the world's type. For terrestrial worlds this will be the primary biome, for instance worlds this will be the instance name, and for ship or generic worlds this will be 'unknown'.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("terrestrial", "Returns a true if the current world is a terrestrial world, i.e. a planet, and false otherwise.", [], {}, "bool"));
tmpClass.methods.push(new LuaMethod("size", "Returns a vector describing the size of the current world.", [], {}, "Vec2I"));
tmpClass.methods.push(new LuaMethod("magnitude", "Returns the magnitude of the distance between the specified world positions. Use this rather than simple vector subtraction to handle world wrapping.", ["Vec2F position1", "Vec2F position2"], {}, "float"));
tmpClass.methods.push(new LuaMethod("distance", "Returns the vector difference between the specified world positions. Use this rather than simple vector subtraction to handle world wrapping.", ["Vec2F position1", "Vec2F position2"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("polyContains", "Returns true if the specified poly contains the specified position in world space and false otherwise.", ["PolyF poly", "Vec2F position"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("xwrap", "Returns the specified position with its X coordinate wrapped around the world width.", ["Vec2F position"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("xwrap", "Returns the specified X position wrapped around the world width.", ["float xPosition"], {}, "float"));
tmpClass.methods.push(new LuaMethod("nearestTo", "Returns the point nearest to (i.e. on the same side of the world as) the source point. Either argument can be specified as a Vec2F point or as a float X position. The type of the targetPosition determines the return type.", ["Variant<Vec2F, float> sourcePosition", "Variant<Vec2F, float> targetPosition"], {}, "Variant<Vec2F,float>"));
tmpClass.methods.push(new LuaMethod("pointCollision", "Returns true if the generated collision geometry at the specified point matches any of the specified collision kinds and false otherwise.", ["Vec2F point", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("pointTileCollision", "Returns true if the tile at the specified point matches any of the specified collision kinds and false otherwise.", ["Vec2F point", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("lineCollision", "If the line between the specified points overlaps any generated collision geometry of the specified collision kinds, returns the point at which the line collides, or nil if the line does not collide.", ["Vec2F startPoint", "Vec2F endPoint", "[CollisionSet collisionKinds]"], {}, "Maybe<Vec2F>"));
tmpClass.methods.push(new LuaMethod("lineTileCollision", "Returns true if the line between the specified points overlaps any tiles of the specified collision kinds and false otherwise.", ["Vec2F startPoint", "Vec2F endPoint", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("lineTileCollisionPoint", "Returns a table of {position,normal} where position is the position that the line intersects the first collidable tile, and normal is the collision normal. Returns nil if no tile is intersected.", ["Vec2F startPoint", "Vec2F endPoint", "[CollisionSet collisionKinds]"], {}, "Maybe<pair<Vec2F,Vec2F>>"));
tmpClass.methods.push(new LuaMethod("rectCollision", "Returns true if the specified rectangle overlaps any generated collision geometry of the specified collision kinds and false otherwise.", ["RectF rect", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("rectTileCollision", "Returns true if the specified rectangle overlaps any tiles of the specified collision kinds and false otherwise.", ["RectF rect", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("polyCollision", "Returns true if the specified polygon overlaps any generated collision geometry of the specified collision kinds and false otherwise. If a position is specified, the polygon coordinates will be treated as relative to that world position.", ["PolyF poly", "[Vec2F position]", "[CollisionSet collisionKinds]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("collisionBlocksAlongLine", "Returns an ordered list of tile positions along the line between the specified points that match any of the specified collision kinds. If maxReturnCount is specified, the function will only return up to that number of points.", ["Vec2F startPoint", "Vec2F endPoint", "[CollisionSet collisionKinds]", "[int maxReturnCount]"], {}, "List<Vec2I>"));
tmpClass.methods.push(new LuaMethod("liquidAlongLine", "Returns a list of pairs containing a position and a LiquidLevel for all tiles along the line between the specified points that contain any liquid.", ["Vec2F startPoint", "Vec2F endPoint"], {}, "List<pair<Vec2I,LiquidLevel>>"));
tmpClass.methods.push(new LuaMethod("resolvePolyCollision", "Attempts to move the specified poly (relative to the specified position) such that it does not collide with any of the specified collision kinds. Will only move the poly up to the distance specified by maximumCorrection. Returns nil if the collision resolution fails.", ["PolyF poly", "Vec2F position", "float maximumCorrection", "[CollisionSet collisionKinds]"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("tileIsOccupied", "Returns true if the specified tile position is occupied by a material or tile entity and false if it is empty. The check will be performed on the foreground tile layer if foregroundLayer is true (or unspecified) and the background tile layer if it is false. The check will include ephemeral tile entities such as preview objects if includeEphemeral is true, and will not include these entities if it is false (or unspecified).", ["Vec2I tilePosition", "[bool foregroundLayer]", "[bool includeEphemeral]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("placeObject", "Attempts to place the specified object into the world at the specified position, preferring it to be right-facing if direction is positive (or unspecified) and left-facing if it is negative. If parameters are specified they will be applied to the object. Returns true if the object is placed successfully and false otherwise.", ["String objectName", "Vec2I tilePosition", "[int direction]", "[Json parameters]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("spawnItem", "Attempts to spawn the specified item into the world as the specified position. If item is specified as a name, it will optionally apply the specified count and parameters. The item drop entity can also be spawned with an initial velocity and intangible time (delay before it can be picked up) if specified. Returns an EntityId of the item drop if successful and nil otherwise.", ["ItemDescriptor item", "Vec2F position", "[unsigned count]", "[Json parameters]", "[Vec2F velocity]", "[float intangibleTime]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("spawnTreasure", "Attempts to spawn all items in an instance of the specified treasure pool with the specified level and seed at the specified world position. Returns a list of EntityIds of the item drops created if successful and nil otherwise.", ["Vec2F position", "String poolName", "float level", "[unsigned seed]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("spawnMonster", "Attempts to spawn a monster of the specified type at the specified position. If parameters are specified they will be applied to the spawned monster. If they are unspecified, they default to an object setting aggressive to be randomly true or false. Level for the monster may be specified in parameters. Returns the EntityId of the spawned monster if successful and nil otherwise.", ["String monsterType", "Vec2F position", "[Json parameters]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("spawnNpc", "Attempts to spawn an NPC of the specified type, species, level with the specified seed and parameters at the specified position. Returns EntityId of the spawned NPC if successful and nil otherwise.", ["Vec2F position", "String species", "String npcType", "float level", "[unsigned seed]", "[Json parameters]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("spawnStagehand", "Attempts to spawn a stagehand of the specified type at the specified position with the specified override parameters. Returns EntityId of the spawned stagehand if successful and nil otherwise.", ["Vec2F position", "String type", "[Json overrides]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("spawnProjectile", "Attempts to spawn a projectile of the specified type at the specified position with the specified source entity id, direction, and parameters. If trackSourceEntity is true then the projectile's position will be locked relative to its source entity's position. Returns the EntityId of the spawned projectile if successful and nil otherwise.", ["String projectileName", "Vec2F position", "[EntityId sourceEntityId]", "[Vec2F direction]", "[bool trackSourceEntity]", "[Json parameters]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("spawnVehicle", "Attempts to spawn a vehicle of the specified type at the specified position with the specified override parameters. Returns the EntityId of the spawned vehicle if successful and nil otherwise.", ["String vehicleName", "Vec2F position", "[Json overrides]"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("threatLevel", "Returns the threat level of the current world.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("time", "Returns the absolute time of the current world.", [], {}, "double"));
tmpClass.methods.push(new LuaMethod("day", "Returns the absolute numerical day of the current world.", [], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("timeOfDay", "Returns a value between 0 and 1 indicating the time within the day of the current world.", [], {}, "double"));
tmpClass.methods.push(new LuaMethod("dayLength", "Returns the duration of a day on the current world.", [], {}, "float"));
tmpClass.methods.push(new LuaMethod("getProperty", "Returns the JSON value of the specified world property, or defaultValue or nil if it is not set.", ["String propertyName", "[Json defaultValue]"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("setProperty", "Sets the specified world property to the specified value.", ["String propertyName", "Json value"], {}, "void"));
tmpClass.methods.push(new LuaMethod("liquidAt", "Returns the LiquidLevel at the specified tile position, or nil if there is no liquid.", ["Vec2I position"], {}, "LiquidLevel"));
tmpClass.methods.push(new LuaMethod("liquidAt", "Returns the average LiquidLevel of the most plentiful liquid within the specified region, or nil if there is no liquid.", ["RectF region"], {}, "LiquidLevel"));
tmpClass.methods.push(new LuaMethod("gravity", "Returns the gravity at the specified position. This should be consistent for all non-dungeon tiles in a world but can be altered by dungeons.", ["Vec2F position"], {}, "float"));
tmpClass.methods.push(new LuaMethod("spawnLiquid", "Attempts to place the specified quantity of the specified liquid at the specified position. Returns true if successful and false otherwise.", ["Vec2F position", "LiquidId liquid", "float quantity"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("destroyLiquid", "Removes any liquid at the specified position and returns the LiquidLevel containing the type and quantity of liquid removed, or nil if no liquid is removed.", ["Vec2F position"], {}, "LiquidLevel"));
tmpClass.methods.push(new LuaMethod("isTileProtected", "Returns true if the tile at the specified position is protected and false otherwise.", ["Vec2F position"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("findPlatformerPath", "Attempts to synchronously pathfind between the specified positions using the specified movement and pathfinding parameters. Returns the path as a list of nodes as successful, or nil if no path is found.", ["Vec2F startPosition", "Vec2F endPosition", "ActorMovementParameters movementParameters", "PlatformerAStar::Parameters searchParameters"], {}, "PlatformerAStar::Path"));
tmpClass.methods.push(new LuaMethod("platformerPathStart", "Creates and returns a Lua UserData value which can be used for pathfinding over multiple frames. The PathFinder returned has the following two methods:", ["Vec2F startPosition", "Vec2F endPosition", "ActorMovementParameters movementParameters", "PlatformerAStar::Parameters searchParameters"], {}, "PlatformerAStar::PathFinder"));
tmpClass.methods.push(new LuaMethod("lightLevel", "Returns the current logical light level at the specified position. Requires recalculation of lighting, so this should be used sparingly.", ["Vec2F position"], {}, "float"));
tmpClass.methods.push(new LuaMethod("windLevel", "Returns the current wind level at the specified position.", ["Vec2F position"], {}, "float"));
tmpClass.methods.push(new LuaMethod("breathable", "Returns true if the world is breathable at the specified position and false otherwise.", ["Vec2F position"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("environmentStatusEffects", "Returns a list of the environmental status effects at the specified position.", ["Vec2F position"], {}, "List<String>"));
tmpClass.methods.push(new LuaMethod("underground", "Returns true if the specified position is below the world's surface level and false otherwise.", ["Vec2F position"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("inSurfaceLayer", "Returns true if the world is terrestrial and the specified position is within its surface layer, and false otherwise.", ["Vec2I position"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("oceanLevel", "If the specified position is within a region that has ocean (endless) liquid, returns the world Y level of that ocean's surface, or 0 if there is no ocean in the specified region.", ["Vec2I position"], {}, "int"));
tmpClass.methods.push(new LuaMethod("material", "Returns the name of the material at the specified position and layer. Layer can be specified as 'foreground' or 'background'. Returns false if the space is empty in that layer. Returns nil if the material is NullMaterial (e.g. if the position is in an unloaded sector).", ["Vec2F position", "String layerName"], {}, "Variant<String,bool>"));
tmpClass.methods.push(new LuaMethod("mod", "Returns the name of the mod at the specified position and layer, or nil if there is no mod.", ["Vec2F position", "String layerName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("materialHueShift", "Returns the hue shift of the material at the specified position and layer.", ["Vec2F position", "String layerName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("modHueShift", "Returns the hue shift of the mod at the specified position and layer.", ["Vec2F position", "String layerName"], {}, "float"));
tmpClass.methods.push(new LuaMethod("materialColor", "Returns the color variant (painted color) of the material at the specified position and layer.", ["Vec2F position", "String layerName"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("setMaterialColor", "Sets the color variant of the material at the specified position and layer to the specified color.", ["Vec2F position", "String layerName", "unsigned color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("damageTiles", "Damages all tiles in the specified layer and positions by the specified amount. The source position of the damage determines the initial direction of the damage particles. Damage types are: \"plantish\", \"blockish\", \"beamish\", \"explosive\", \"fire\", \"tilling\". Harvest level determines whether destroyed materials or mods will drop as items. Returns true if any damage was done and false otherwise.", ["List<Vec2I> positions", "String layerName", "Vec2F sourcePosition", "String damageType", "float damageAmount", "[unsigned harvestLevel]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("damageTileArea", "Identical to world.damageTiles but applies to tiles in a circular radius around the specified center point.", ["Vec2F center", "float radius", "String layerName", "Vec2F sourcePosition", "String damageType", "float damageAmount", "[unsigned harvestLevel"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("placeMaterial", "Attempts to place the specified material in the specified position and layer. If allowOverlap is true the material can be placed in a space occupied by mobile entities, otherwise such placement attempts will fail. Returns true if the placement succeeds and false otherwise.", ["Vec2I position", "String layerName", "String materialName", "[int hueShift]", "[bool allowOverlap]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("placeMod", "Attempts to place the specified mod in the specified position and layer. If allowOverlap is true the mod can be placed in a space occupied by mobile entities, otherwise such placement attempts will fail. Returns true if the placement succeeds and false otherwise.", ["Vec2I position", "String layerName", "String modName", "[int hueShift]", "[bool allowOverlap]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("entityQuery", "Queries for entities in a specified area of the world and returns a list of their entity ids. Area can be specified either as the Vec2F lower left and upper right positions of a rectangle, or as the Vec2F center and float radius of a circular area. The following additional parameters can be specified in options:", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("monsterQuery", "Identical to world.entityQuery but only considers monsters.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("npcQuery", "Identical to world.entityQuery but only considers NPCs.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("objectQuery", "Similar to world.entityQuery but only considers objects. Allows an additional option, __name__, which specifies a String object type name and will only return objects of that type.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("itemDropQuery", "Identical to world.entityQuery but only considers item drops.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("playerQuery", "Identical to world.entityQuery but only considers players.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("loungeableQuery", "Similar to world.entityQuery but only considers loungeable entities. Allows an additional option, __orientation__, which specifies the String name of a loungeable orientation (\"sit\", \"lay\" or \"stand\") and only returns loungeable entities which use that orientation.", ["Vec2F position", "Variant<Vec2F, float positionOrRadius", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("entityLineQuery", "Similar to world.entityQuery but only returns entities that intersect the line between the specified positions.", ["Vec2F startPosition", "Vec2F endPosition", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("objectLineQuery", "Identical to world.entityLineQuery but only considers objects.", ["Vec2F startPosition", "Vec2F endPosition", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("npcLineQuery", "Identical to world.entityLineQuery but only considers NPCs.", ["Vec2F startPosition", "Vec2F endPosition", "[Json options]"], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("objectAt", "Returns the entity id of any object occupying the specified tile position, or nil if the position is not occupied by an object.", ["Vec2I tilePosition"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("entityExists", "Returns true if an entity with the specified id exists in the world and false otherwise.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("entityDamageTeam", "Returns the current damage team (team type and team number) of the specified entity, or nil if the entity doesn't exist.", ["EntityId entityId"], {}, "DamageTeam"));
tmpClass.methods.push(new LuaMethod("entityCanDamage", "Returns true if the specified source entity can damage the specified target entity using their current damage teams and false otherwise.", ["EntityId sourceId", "EntityId targetId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("entityAggressive", "Returns true if the specified entity is an aggressive monster or NPC and false otherwise.", ["EntityId entity"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("entityType", "Returns the entity type name of the specified entity, or nil if the entity doesn't exist.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityPosition", "Returns the current world position of the specified entity, or nil if the entity doesn't exist.", ["EntityId entityId"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityMouthPosition", "Returns the current world mouth position of the specified player, monster, NPC or object, or nil if the entity doesn't exist or isn't a valid type.", ["EntityId entityId"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityVelocity", "Returns the current velocity of the entity if it is a vehicle, monster, NPC or player and nil otherwise.", ["EntityId entityId"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entityCurrency", "Returns the specified player entity's stock of the specified currency type, or nil if the entity is not a player.", ["EntityId entityId", "String currencyType"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("entityHasCountOfItem", "Returns the nubmer of the specified item that the specified player entity is currently carrying, or nil if the entity is not a player. If exactMatch is true then parameters as well as item name must match.\n\nNOTE: This function currently does not work correctly over the network, making it inaccurate when not used from client side scripts such as status.", ["EntityId entityId", "Json itemDescriptor", "[bool exactMatch]"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("entityHealth", "Returns a Vec2F containing the specified entity's current and maximum health if the entity is a player, monster or NPC and nil otherwise.", ["EntityId entityId"], {}, "Vec2F"));
tmpClass.methods.push(new LuaMethod("entitySpecies", "Returns the name of the specified entity's species if it is a player or NPC and nil otherwise.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityGender", "Returns the name of the specified entity's gender if it is a player or NPC and nil otherwise.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityName", "Returns a String name of the specified entity which has different behavior for different entity types. For players, monsters and NPCs, this will be the configured name of the specific entity. For objects or vehicles, this will be the name of the object or vehicle type. For item drops, this will be the name of the contained item.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityTypeName", "Similar to world.entityName but returns the names of configured types for NPCs and monsters.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityDescription", "Returns the configured description for the specified inspectable entity (currently only objects and plants support this). Will return a species-specific description if species is specified and a generic description otherwise.", ["EntityId entityId", "[String species]"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityPortrait", "Generates a portrait of the specified entity in the specified portrait mode and returns a list of drawables, or nil if the entity is not a portrait entity.", ["EntityId entityId", "String portraitMode"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("entityHandItem", "Returns the name of the item held in the specified hand of the specified player or NPC, or nil if the entity is not holding an item or is not a player or NPC. Hand name should be specified as \"primary\" or \"alt\".", ["EntityId entityId", "String handName"], {}, "String"));
tmpClass.methods.push(new LuaMethod("entityHandItemDescriptor", "Similar to world.entityHandItem but returns the full descriptor of the item rather than the name.", ["EntityId entityId", "String handName"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("itemDropItem", "Returns the item descriptor of an item drop's contents.", ["EntityId entityId"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("entityUniqueId", "Returns the unique id of the specified entity, or nil if the entity does not have a unique id.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("getObjectParameter", "Returns the value of the specified object's config parameter, or defaultValue or nil if the parameter is not set or the entity is not an object.", ["EntityId entityId", "String parameterName", "[Json defaultValue]"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("objectSpaces", "Returns a list of tile positions that the specified object occupies, or nil if the entity is not an object.", ["EntityId entityId"], {}, "List<Vec2I>"));
tmpClass.methods.push(new LuaMethod("farmableStage", "Returns the current growth stage of the specified farmable object, or nil if the entity is not a farmable object.", ["EntityId entityId"], {}, "int"));
tmpClass.methods.push(new LuaMethod("containerSize", "Returns the total capacity of the specified container, or nil if the entity is not a container.", ["EntityId entityId"], {}, "int"));
tmpClass.methods.push(new LuaMethod("containerClose", "Visually closes the specified container. Returns true if the entity is a container and false otherwise.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("containerOpen", "Visually opens the specified container. Returns true if the entity is a container and false otherwise.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("containerItems", "Returns a list of pairs of item descriptors and container positions of all items in the specified container, or nil if the entity is not a container.", ["EntityId entityId"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("containerItemAt", "Returns an item descriptor of the item at the specified position in the specified container, or nil if the entity is not a container or the offset is out of range.", ["EntityId entityId", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerConsume", "Attempts to consume items from the specified container that match the specified item descriptor and returns true if successful,false if unsuccessful, or nil if the entity is not a container. Only succeeds if the full count of the specified item can be consumed.", ["EntityId entityId", "ItemDescriptor item"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("containerConsumeAt", "Similar to world.containerConsume but only considers the specified slot within the container.", ["EntityId entityId", "unsigned offset", "unsigned count"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("containerAvailable", "Returns the number of the specified item that are currently available to consume in the specified container, or nil if the entity is not a container.", ["EntityId entityId", "ItemDescriptor item"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("containerTakeAll", "Similar to world.containerItems but consumes all items in the container.", ["EntityId entityId"], {}, "JsonArray"));
tmpClass.methods.push(new LuaMethod("containerTakeAt", "Similar to world.containerItemAt, but consumes all items in the specified slot of the container.", ["EntityId entityId", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerTakeNumItemsAt", "Similar to world.containerTakeAt, but consumes up to (but not necessarily equal to) the specified count of items from the specified slot of the container and returns only the items consumed.", ["EntityId entityId", "unsigned offset", "unsigned count"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerItemsCanFit", "Returns the number of times the specified item can fit in the specified container, or nil if the entity is not a container.", ["EntityId entityId", "ItemDescriptor item"], {}, "unsigned"));
tmpClass.methods.push(new LuaMethod("containerItemsFitWhere", "Returns a JsonObject containing a list of \"slots\" the specified item would fit and the count of \"leftover\" items that would remain after attempting to add the items. Returns nil if the entity is not a container.", ["EntityId entityId", "ItemDescriptor items"], {}, "Json"));
tmpClass.methods.push(new LuaMethod("containerAddItems", "Adds the specified items to the specified container. Returns the leftover items after filling the container, or all items if the entity is not a container.", ["EntityId entityId", "ItemDescriptor items"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerStackItems", "Similar to world.containerAddItems but will only combine items with existing stacks and will not fill empty slots.", ["EntityId entityId", "ItemDescriptor items"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerPutItemsAt", "Similar to world.containerAddItems but only considers the specified slot in the container.", ["EntityId entityId", "ItemDescriptor items", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerItemApply", "Attempts to combine the specified items with the current contents (if any) of the specified container slot and returns any items unable to be placed into the slot.", ["EntityId entityId", "ItemDescriptor items", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerSwapItemsNoCombine", "Places the specified items into the specified container slot and returns the previous contents of the slot if successful, or the original items if unsuccessful.", ["EntityId entityId", "ItemDescriptor items", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("containerSwapItems", "A combination of world.containerItemApply and world.containerSwapItemsNoCombine that attempts to combine items before swapping and returns the leftovers if stacking was successful or the previous contents of the container slot if the items did not stack.", ["EntityId entityId", "ItemDescriptor items", "unsigned offset"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("callScriptedEntity", "Attempts to call the specified function name in the context of the specified scripted entity with the specified arguments and returns the result. This method is synchronous and thus can only be used on local master entities, i.e. scripts run on the server may only call scripted entities that are also server-side master and scripts run on the client may only call scripted entities that are client-side master on that client. For more featureful entity messaging, use world.sendEntityMessage.", ["EntityId entityId", "String functionName", "[LuaValue args ...]"], {}, "LuaValue"));
tmpClass.methods.push(new LuaMethod("sendEntityMessage", "Sends an asynchronous message to an entity with the specified entity id or unique id with the specified message type and arguments and returns an RpcPromise which can be used to receive the result of the message when available. See the message table for information on entity message handling. This function __should not be called in any entity's init function__ as the sending entity will not have been fully loaded.", ["Variant<EntityId, String> entityId", "String messageType", "[LuaValue args ...]"], {}, "RpcPromise<Json>"));
tmpClass.methods.push(new LuaMethod("findUniqueEntity", "Attempts to find an entity on the server by unique id and returns an RpcPromise that can be used to get the position of that entity if successful.", ["String uniqueId"], {}, "RpcPromise<Vec2F>"));
tmpClass.methods.push(new LuaMethod("loungeableOccupied", "Checks whether the specified loungeable entity is currently occupied and returns true if it is occupied,false if it is unoccupied, or nil if it is not a loungeable entity.", ["EntityId entityId"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isMonster", "Returns true if the specified entity exists and is a monster and false otherwise. If aggressive is specified, will return false unless the monster's aggressive state matches the specified value.", ["EntityId entityId", "[bool aggressive]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("monsterType", "Returns the monster type of the specified monster, or nil if the entity is not a monster.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("isNpc", "Returns true if the specified entity exists and is an NPC and false otherwise. If damageTeam is specified, will return false unless the NPC's damage team number matches the specified value.", ["EntityId entityId", "[int damageTeam]"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("npcType", "Returns the NPC type of the specified NPC, or nil if the entity is not an NPC.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("stagehandType", "Returns the stagehand type of the specified stagehand, or nil if the entity is not a stagehand.", ["EntityId entityId"], {}, "String"));
tmpClass.methods.push(new LuaMethod("debugPoint", "Displays a point visible in debug mode at the specified world position.", ["Vec2F position", "Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("debugLine", "Displayes a line visible in debug mode between the specified world positions.", ["Vec2F startPosition", "Vec2F endPosition", "Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("debugPoly", "Displays a polygon consisting of the specified points that is visible in debug mode.", ["PolyF poly", "Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("debugText", "Displays text visible in debug mode at the specified position using the specified format string and optional formatted values.\n\nThe following additional world bindings are available only for scripts running on the server.", ["String formatString", "[LuaValue formatValues ...]", "Vec2F position", "Color color"], {}, "void"));
tmpClass.methods.push(new LuaMethod("breakObject", "Breaks the specified object and returns true if successful and false otherwise. If smash is true the object will not (by default) drop any items.", ["EntityId entityId", "bool smash"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("isVisibleToPlayer", "Returns true if any part of the specified region overlaps any player's screen area and false otherwise.", ["RectF region"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("loadRegion", "Attempts to load all sectors overlapping the specified region and returns true if all sectors are fully loaded and false otherwise.", ["RectF region"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("regionActive", "Returns true if all sectors overlapping the specified region are fully loaded and false otherwise.", ["RectF region"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("setTileProtection", "Enables or disables tile protection for the specified dungeon id.", ["DungeonId dungeonId", "bool protected"], {}, "void"));
tmpClass.methods.push(new LuaMethod("dungeonId", "Returns the dungeon id at the specified world position.", ["Vec2F position"], {}, "DungeonId"));
tmpClass.methods.push(new LuaMethod("setDungeonId", "Sets the dungeonId of all tiles within the specified area.", ["RectI tileArea", "DungeonId dungeonId"], {}, "DungeonId"));
tmpClass.methods.push(new LuaMethod("isPlayerModified", "Returns true if any tile within the specified region has been modified (placed or broken) by a player and false otherwise.", ["RectI region"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("forceDestroyLiquid", "Identical to world.destroyLiquid but ignores tile protection.", ["Vec2F position"], {}, "LiquidLevel"));
tmpClass.methods.push(new LuaMethod("loadUniqueEntity", "Forces (synchronous) loading of the specified unique entity and returns its non-unique entity id or 0 if no such unique entity exists.", ["String uniqueId"], {}, "EntityId"));
tmpClass.methods.push(new LuaMethod("setUniqueId", "Sets the unique id of the specified entity to the specified unique id or clears it if no unique id is specified.", ["EntityId entityId", "[String uniqueId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("takeItemDrop", "Takes the specified item drop and returns an ItemDescriptor of its contents or nil if the operation fails. If a source entity id is specified, the item drop will briefly animate toward that entity.", ["EntityId targetEntityId", "[EntityId sourceEntityId]"], {}, "ItemDescriptor"));
tmpClass.methods.push(new LuaMethod("setPlayerStart", "Sets the world's default beam-down point to the specified position. If respawnInWorld is set to true then players who die in that world will respawn at the specified start position rather than being returned to their ships.", ["Vec2F position", "[bool respawnInWorld]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("players", "Returns a list of the entity ids of all players currently in the world.", [], {}, "List<EntityId>"));
tmpClass.methods.push(new LuaMethod("fidelity", "Returns the name of the fidelity level at which the world is currently running. See worldserver.config for fidelity configuration.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("flyingType", "Returns the current flight status of a ship world.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("warpPhase", "Returns the current warp phase of a ship world.", [], {}, "String"));
tmpClass.methods.push(new LuaMethod("setUniverseFlag", "Sets the specified universe flag on the current universe.", ["String flagName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("universeFlags", "Returns a list of all universe flags set on the current universe.", [], {}, "List<String>"));
tmpClass.methods.push(new LuaMethod("universeFlagSet", "Returns true if the specified universe flag is set and false otherwise.", ["String flagName"], {}, "bool"));
tmpClass.methods.push(new LuaMethod("skyTime", "Returns the current time for the world's sky.", [], {}, "double"));
tmpClass.methods.push(new LuaMethod("setSkyTime", "Sets the current time for the world's sky to the specified value.", ["double time"], {}, "void"));
tmpClass.methods.push(new LuaMethod("placeDungeon", "Generates the specified dungeon in the world at the specified position, ignoring normal dungeon anchoring rules. If a dungeon id is specified, it will be assigned to the dungeon.", ["String dungeonName", "Vec2I position", "[DungeonId dungeonId]"], {}, "void"));
tmpClass.methods.push(new LuaMethod("addBiomeRegion", "Adds a biome region to the world, centered on position,width blocks wide.", ["Vec2I position", "String biomeName", "String subBlockSelector", "int width"], {}, "void"));
tmpClass.methods.push(new LuaMethod("expandBiomeRegion", "Expands the biome region currently at position by width blocks.", ["Vec2I position", "int width"], {}, "void"));
tmpClass.methods.push(new LuaMethod("pregenerateAddBiome", "Signals a region for asynchronous generation. The region signaled is the region that needs to be generated to add a biome region of width tiles to position.", ["Vec2I position", "int width"], {}, "void"));
tmpClass.methods.push(new LuaMethod("pregenerateExpandBiome", "Signals a region for asynchronous generation. The region signaled is the region that needs to be generated to expand the biome at position by width blocks.", ["Vec2I position", "int width"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setLayerEnvironmentBiome", "Sets the environment biome for a layer to the biome at position.", ["Vec2I position"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setPlanetType", "Sets the planet type of the current world to planetType with primary biome primaryBiomeName.", ["String planetType", "String, primaryBiomeName"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDungeonGravity", "Sets the overriding gravity for the specified dungeon id, or returns it to the world default if unspecified.", ["DungeonId dungeonId", "Maybe<float> gravity"], {}, "void"));
tmpClass.methods.push(new LuaMethod("setDungeonBreathable", "Sets the overriding breathability for the specified dungeon id, or returns it to the world default if unspecified.", ["DungeonId dungeonId", "Maybe<bool> breathable"], {}, "void"));
luaClasses.push(tmpClass);

luaFunctions.push(new LuaMethod("size", "Returns the size of the canvas.", [], {}, "Vec2I"));
luaFunctions.push(new LuaMethod("clear", "Clears the canvas.", [], {}, "void"));
luaFunctions.push(new LuaMethod("mousePosition", "Returns the mouse position relative to the canvas.", [], {}, "Vec2I"));
luaFunctions.push(new LuaMethod("drawImage", "Draws an image to the canvas.", ["String image", "Vec2F position", "[float scale]", "[Color color]", "[bool centered]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawImageDrawable", "Draws an image to the canvas, centered on position, with slightly different options.", ["String image", "Vec2F position", "[Variant<Vec2F, float> scale]", "[Color color]", "[float rotation]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawImageRect", "Draws a rect section of a texture to a rect section of the canvas.", ["String texName", "RectF texCoords", "RectF screenCoords", "[Color color]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawTiledImage", "Draws an image tiled (and wrapping) within the specified screen area.", ["String image", "Vec2F offset", "RectF screenCoords", "[float scale]", "[Color color]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawLine", "Draws a line on the canvas.", ["Vec2F start", "Vec2F end", "[Color color]", "[float lineWidth]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawRect", "Draws a filled rectangle on the canvas.", ["RectF rect", "Color color"], {}, "void"));
luaFunctions.push(new LuaMethod("drawPoly", "Draws a polygon on the canvas.", ["PolyF poly", "Color color", "[float lineWidth]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawTriangles", "Draws a list of filled triangles to the canvas.", ["List<PolyF> triangles", "[Color color]"], {}, "void"));
luaFunctions.push(new LuaMethod("drawText", "Draws text on the canvas.", ["String text", "Json textPositioning", "unsigned fontSize", "[Color color]"], {}, "void"));
// WORLD
luaFunctions.push(new LuaMethod("explore", "Explores the path up to the specified node count limit. Returns true if the pathfinding is complete and false if it is still incomplete. If nodeLimit is unspecified, this will search up to the configured maximum number of nodes, making it equivalent to world.platformerPathStart.", ["[int nodeLimit]"], {}, "bool"));
luaFunctions.push(new LuaMethod("result", "Returns the completed path.", [], {}, "PlatformerAStar::Path"));
// Global
luaFunctions.push(new LuaMethod("init", "Reinitializes the random source, optionally using the specified seed.", ["[unsigned seed]"], {}, "void"));
luaFunctions.push(new LuaMethod("addEntropy", "Adds entropy to the random source, optionally using the specified seed.", ["[unsigned seed]"], {}, "void"));
luaFunctions.push(new LuaMethod("randu32", "Returns a random 32-bit unsigned integer value.", [], {}, "unsigned"));
luaFunctions.push(new LuaMethod("randu64", "Returns a random 64-bit unsigned integer value.", [], {}, "unsigned"));
luaFunctions.push(new LuaMethod("randi32", "Returns a random 32-bit signed integer value.", [], {}, "int"));
luaFunctions.push(new LuaMethod("randi64", "Returns a random 64-bit signed integer value.", [], {}, "int"));
luaFunctions.push(new LuaMethod("randf", "Returns a random float value within the specified range, or between 0 and 1 if no range is specified.", ["[float min]", "[float max]"], {}, "float"));
luaFunctions.push(new LuaMethod("randf", "Returns a random double value within the specified range, or between 0 and 1 if no range is specified.", ["[double min]", "[double max]"], {}, "double"));
luaFunctions.push(new LuaMethod("randf", "Returns a random unsigned integer value between minOrMax and max, or between 0 and minOrMax if no max is specified.", ["unsigned minOrMax", "[unsigned max]"], {}, "unsigned"));
luaFunctions.push(new LuaMethod("randf", "Returns a random signed integer value between minOrMax and max, or between 0 and minOrMax if no max is specified.", ["[int min]", "[int max]"], {}, "int"));
luaFunctions.push(new LuaMethod("randb", "Returns a random bool value.", [], {}, "bool"));
luaFunctions.push(new LuaMethod("perlinsource.get", "Returns a float value from the Perlin source using 1, 2, or 3 dimensions of input.", ["float x", "[float y]", "[float z]"], {}, "float"));

/** 
 * #####################
 * LUA LIBRARY FUNCTIONS
 * #####################
 */

tmpClass = new LuaClass("string");
tmpClass.methods.push(new LuaMethod("byte", "Returns the internal numeric codes of the characters s[i], s[i+1], ..., s[j]. The default value for i is 1; the default value for j is i. These indices are corrected following the same rules of function string.sub."));
tmpClass.methods.push(new LuaMethod("char", "Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument."));
tmpClass.methods.push(new LuaMethod("dump", "Returns a string containing a binary representation (a binary chunk) of the given function, so that a later load on this string returns a copy of the function (but with new upvalues). If strip is a true value, the binary representation may not include all debug information about the function, to save space."));
tmpClass.methods.push(new LuaMethod("find", "Looks for the first match of pattern (see §6.4.1) in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numeric argument init specifies where to start the search; its default value is 1 and can be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain \"find substring\" operation, with no characters in pattern being considered magic. Note that if plain is given, then init must be given as well."));
tmpClass.methods.push(new LuaMethod("format", "Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function sprintf. The only differences are that the options/modifiers *, h, L, l, n, and p are not supported and that there is an extra option, q."));
tmpClass.methods.push(new LuaMethod("gmatch", "Returns an iterator function that, each time it is called, returns the next captures from pattern (see §6.4.1) over the string s. If pattern specifies no captures, then the whole match is produced in each call."));
tmpClass.methods.push(new LuaMethod("gsub", "Returns a copy of s in which all (or the first n, if given) occurrences of the pattern (see §6.4.1) have been replaced by a replacement string specified by repl, which can be a string, a table, or a function. gsub also returns, as its second value, the total number of matches that occurred. The name gsub comes from Global SUBstitution."));
tmpClass.methods.push(new LuaMethod("len", "Receives a string and returns its length. The empty string has length 0. Embedded zeros are counted."));
tmpClass.methods.push(new LuaMethod("lower", "Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale."));
tmpClass.methods.push(new LuaMethod("match", "Looks for the first match of pattern (see §6.4.1) in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numeric argument init specifies where to start the search; its default value is 1 and can be negative. "));
tmpClass.methods.push(new LuaMethod("rep", "Returns a string that is the concatenation of n copies of the string s separated by the string sep. The default value for sep is the empty string (that is, no separator). Returns the empty string if n is not positive."));
tmpClass.methods.push(new LuaMethod("reverse", "Returns a string that is the string s reversed. "));
tmpClass.methods.push(new LuaMethod("sub", "Returns the substring of s that starts at i and continues until j; i and j can be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) (for a positive i) returns a suffix of s with length i."));
tmpClass.methods.push(new LuaMethod("upper", "Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale."));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("table");
tmpClass.methods.push(new LuaMethod("concat", "Given a list where all elements are strings or numbers, returns the string list[i]..sep..list[i+1] ··· sep..list[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is #list. If i is greater than j, returns the empty string.", ["list", "[sep]", "[i]", "[j]"]));
tmpClass.methods.push(new LuaMethod("insert", "Inserts element value at position pos in list, shifting up the elements list[pos], list[pos+1], ···, list[#list]. The default value for pos is #list+1, so that a call table.insert(t,x) inserts x at the end of list t.", ["list", "[pos]", "value"]));
tmpClass.methods.push(new LuaMethod("remove", "Removes from list the element at position pos, returning the value of the removed element. When pos is an integer between 1 and #list, it shifts down the elements list[pos+1], list[pos+2], ···, list[#list] and erases element list[#list]; The index pos can also be 0 when #list is 0, or #list + 1; in those cases, the function erases the element list[pos].", ["list", "[pos]"]));
tmpClass.methods.push(new LuaMethod("sort", "Sorts list elements in a given order, in-place, from list[1] to list[#list]. If comp is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, i < j implies not comp(list[j],list[i])). If comp is not given, then the standard Lua operator < is used instead.", ["list", "[comp]"]));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("math");
tmpClass.methods.push(new LuaMethod("abs", "Returns the absolute value of x. (integer/float)", ["x"]));
tmpClass.methods.push(new LuaMethod("acos", "Returns the arc cosine of x (in radians).", ["x"]));
tmpClass.methods.push(new LuaMethod("asin", "Returns the arc sine of x (in radians).", ["x"]));
tmpClass.methods.push(new LuaMethod("atan", "Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)", ["y", "[x]"]));
tmpClass.methods.push(new LuaMethod("ceil", "Returns the smallest integral value larger than or equal to x.", ["x"]));
tmpClass.methods.push(new LuaMethod("cos", "Returns the cosine of x (assumed to be in radians).", ["x"]));
tmpClass.methods.push(new LuaMethod("deg", "Converts the angle x from radians to degrees.", ["x"]));
tmpClass.methods.push(new LuaMethod("exp", "Returns the value ex (where e is the base of natural logarithms).", ["x"]));
tmpClass.methods.push(new LuaMethod("floor", "Returns the largest integral value smaller than or equal to x.", ["x"]));
tmpClass.methods.push(new LuaMethod("fmod", "Returns the remainder of the division of x by y that rounds the quotient towards zero. (integer/float)", ["x", "y"]));
tmpClass.methods.push(new LuaMethod("log", "Returns the logarithm of x in the given base. The default for base is e (so that the function returns the natural logarithm of x).", ["x", "[base]"]));
tmpClass.methods.push(new LuaMethod("max", "Returns the argument with the maximum value, according to the Lua operator <. (integer/float)", ["x", "..."]));
tmpClass.methods.push(new LuaMethod("min", "Returns the argument with the minimum value, according to the Lua operator <. (integer/float)", ["x", "..."]));
tmpClass.methods.push(new LuaMethod("modf", "Returns the integral part of x and the fractional part of x. Its second result is always a float.", ["x"]));
tmpClass.methods.push(new LuaMethod("rad", "Converts the angle x from degrees to radians.", ["x"]));
tmpClass.methods.push(new LuaMethod("random", "When called without arguments, returns a pseudo-random float with uniform distribution in the range [0,1). When called with two integers m and n, math.random returns a pseudo-random integer with uniform distribution in the range [m, n]. (The value n-m cannot be negative and must fit in a Lua integer.) The call math.random(n) is equivalent to math.random(1,n).", ["[m]", "[n]"]));
tmpClass.methods.push(new LuaMethod("randomseed", "Sets x as the \"seed\" for the pseudo-random generator: equal seeds produce equal sequences of numbers.", ["x"]));
tmpClass.methods.push(new LuaMethod("sin", "Returns the sine of x (assumed to be in radians).", ["x"]));
tmpClass.methods.push(new LuaMethod("sqrt", "Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)", ["x"]));
tmpClass.methods.push(new LuaMethod("tan", "Returns the tangent of x (assumed to be in radians).", ["x"]));
luaClasses.push(tmpClass);

/*
tmpClass = new LuaClass("io");
tmpClass.methods.push(new LuaMethod("close"));
tmpClass.methods.push(new LuaMethod("flush"));
tmpClass.methods.push(new LuaMethod("input"));
tmpClass.methods.push(new LuaMethod("lines"));
tmpClass.methods.push(new LuaMethod("open"));
tmpClass.methods.push(new LuaMethod("output"));
tmpClass.methods.push(new LuaMethod("popen"));
tmpClass.methods.push(new LuaMethod("read"));
tmpClass.methods.push(new LuaMethod("tmpfile"));
tmpClass.methods.push(new LuaMethod("type"));
tmpClass.methods.push(new LuaMethod("write"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("os");
tmpClass.methods.push(new LuaMethod("clock"));
tmpClass.methods.push(new LuaMethod("date"));
tmpClass.methods.push(new LuaMethod("difftime"));
tmpClass.methods.push(new LuaMethod("execute"));
tmpClass.methods.push(new LuaMethod("exit"));
tmpClass.methods.push(new LuaMethod("getenv"));
tmpClass.methods.push(new LuaMethod("remove"));
tmpClass.methods.push(new LuaMethod("rename"));
tmpClass.methods.push(new LuaMethod("setlocale"));
tmpClass.methods.push(new LuaMethod("time"));
tmpClass.methods.push(new LuaMethod("tmpname"));
luaClasses.push(tmpClass);

tmpClass = new LuaClass("package");
tmpClass.methods.push(new LuaMethod("cpath"));
tmpClass.methods.push(new LuaMethod("loaded"));
tmpClass.methods.push(new LuaMethod("loadlib"));
tmpClass.methods.push(new LuaMethod("path"));
tmpClass.methods.push(new LuaMethod("preload"));
tmpClass.methods.push(new LuaMethod("seeall"));
luaClasses.push(tmpClass);
*/

luaFunctions.push(new LuaMethod("assert"));
luaFunctions.push(new LuaMethod("print", "Receives any number of arguments and prints their values to stdout, using the tostring function to convert each argument to a string. print is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use string.format and io.write.", ["..."]));
luaFunctions.push(new LuaMethod("tonumber"));
luaFunctions.push(new LuaMethod("tostring"));
luaFunctions.push(new LuaMethod("type"));
luaFunctions.push(new LuaMethod("unpack"));
luaFunctions.push(new LuaMethod("ipairs", "Returns three values (an iterator function, the table t, and 0) so that the construction\n\n`for i,v in ipairs(t) do body end`\n\nwill iterate over the key–value pairs (1,t[1]), (2,t[2]), ..., up to the first nil value.", ["Table t"]));
luaFunctions.push(new LuaMethod("pairs", "If t has a metamethod __pairs, calls it with t as argument and returns the first three results from the call.\n\nOtherwise, returns three values: the next function, the table t, and nil, so that the construction\n\n`for k,v in pairs(t) do body end`\n\nwill iterate over all key–value pairs of table t.\n\nSee function next for the caveats of modifying the table during its traversal.", ["Table t"]));

luaConsts.push(new LuaConst("_G", "A global variable (not a function) that holds the global environment (see §2.2). Lua itself does not use this variable; changing its value does not affect any environment, nor vice versa."));
luaConsts.push(new LuaConst("_VERSION", "A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is \"Lua 5.3\"."));
luaConsts.push(new LuaConst("math.pi", ""));
luaConsts.push(new LuaConst("math.huge", ""));
/*
coroutine\\.(create|resume|running|status|wrap|yield)|
string\\.(byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|
table\\.(concat|insert|maxn|remove|sort)|
math\\.(abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?)|
io\\.(close|flush|input|lines|open|output|popen|read|tmpfile|type|write)|
os\\.(clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|
package\\.(cpath|loaded|loadlib|path|preload|seeall)|
debug\\.(debug|[gs]etfenv|[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue|traceback))

*/